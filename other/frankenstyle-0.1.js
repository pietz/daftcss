(function () {
    "use strict"; const Ti = globalThis, Mi = Ti.ShadowRoot && (Ti.ShadyCSS === void 0 || Ti.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, xs = Symbol(), Hn = new WeakMap; let ys = class { constructor(l, h, d) { if (this._$cssResult$ = !0, d !== xs) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead."); this.cssText = l, this.t = h } get styleSheet() { let l = this.o; const h = this.t; if (Mi && l === void 0) { const d = h !== void 0 && h.length === 1; d && (l = Hn.get(h)), l === void 0 && ((this.o = l = new CSSStyleSheet).replaceSync(this.cssText), d && Hn.set(h, l)) } return l } toString() { return this.cssText } }; const zn = p => new ys(typeof p == "string" ? p : p + "", void 0, xs), Ca = (p, ...l) => { const h = p.length === 1 ? p[0] : l.reduce(((d, f, $) => d + (b => { if (b._$cssResult$ === !0) return b.cssText; if (typeof b == "number") return b; throw Error("Value passed to 'css' function must be a 'css' function result: " + b + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.") })(f) + p[$ + 1]), p[0]); return new ys(h, p, xs) }, Ln = (p, l) => { if (Mi) p.adoptedStyleSheets = l.map((h => h instanceof CSSStyleSheet ? h : h.styleSheet)); else for (const h of l) { const d = document.createElement("style"), f = Ti.litNonce; f !== void 0 && d.setAttribute("nonce", f), d.textContent = h.cssText, p.appendChild(d) } }, ks = Mi ? p => p : p => p instanceof CSSStyleSheet ? (l => { let h = ""; for (const d of l.cssRules) h += d.cssText; return zn(h) })(p) : p; const { is: Pa, defineProperty: Ia, getOwnPropertyDescriptor: Ta, getOwnPropertyNames: Ma, getOwnPropertySymbols: Oa, getPrototypeOf: Da } = Object, Oi = globalThis, Fn = Oi.trustedTypes, Na = Fn ? Fn.emptyScript : "", Ba = Oi.reactiveElementPolyfillSupport, qe = (p, l) => p, Ue = { toAttribute(p, l) { switch (l) { case Boolean: p = p ? Na : null; break; case Object: case Array: p = p == null ? p : JSON.stringify(p) }return p }, fromAttribute(p, l) { let h = p; switch (l) { case Boolean: h = p !== null; break; case Number: h = p === null ? null : Number(p); break; case Object: case Array: try { h = JSON.parse(p) } catch { h = null } }return h } }, Di = (p, l) => !Pa(p, l), jn = { attribute: !0, type: String, converter: Ue, reflect: !1, useDefault: !1, hasChanged: Di }; Symbol.metadata ??= Symbol("metadata"), Oi.litPropertyMetadata ??= new WeakMap; let Qt = class extends HTMLElement { static addInitializer(l) { this._$Ei(), (this.l ??= []).push(l) } static get observedAttributes() { return this.finalize(), this._$Eh && [...this._$Eh.keys()] } static createProperty(l, h = jn) { if (h.state && (h.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(l) && ((h = Object.create(h)).wrapped = !0), this.elementProperties.set(l, h), !h.noAccessor) { const d = Symbol(), f = this.getPropertyDescriptor(l, d, h); f !== void 0 && Ia(this.prototype, l, f) } } static getPropertyDescriptor(l, h, d) { const { get: f, set: $ } = Ta(this.prototype, l) ?? { get() { return this[h] }, set(b) { this[h] = b } }; return { get: f, set(b) { const C = f?.call(this); $?.call(this, b), this.requestUpdate(l, C, d) }, configurable: !0, enumerable: !0 } } static getPropertyOptions(l) { return this.elementProperties.get(l) ?? jn } static _$Ei() { if (this.hasOwnProperty(qe("elementProperties"))) return; const l = Da(this); l.finalize(), l.l !== void 0 && (this.l = [...l.l]), this.elementProperties = new Map(l.elementProperties) } static finalize() { if (this.hasOwnProperty(qe("finalized"))) return; if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(qe("properties"))) { const h = this.properties, d = [...Ma(h), ...Oa(h)]; for (const f of d) this.createProperty(f, h[f]) } const l = this[Symbol.metadata]; if (l !== null) { const h = litPropertyMetadata.get(l); if (h !== void 0) for (const [d, f] of h) this.elementProperties.set(d, f) } this._$Eh = new Map; for (const [h, d] of this.elementProperties) { const f = this._$Eu(h, d); f !== void 0 && this._$Eh.set(f, h) } this.elementStyles = this.finalizeStyles(this.styles) } static finalizeStyles(l) { const h = []; if (Array.isArray(l)) { const d = new Set(l.flat(1 / 0).reverse()); for (const f of d) h.unshift(ks(f)) } else l !== void 0 && h.push(ks(l)); return h } static _$Eu(l, h) { const d = h.attribute; return d === !1 ? void 0 : typeof d == "string" ? d : typeof l == "string" ? l.toLowerCase() : void 0 } constructor() { super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev() } _$Ev() { this._$ES = new Promise((l => this.enableUpdating = l)), this._$AL = new Map, this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((l => l(this))) } addController(l) { (this._$EO ??= new Set).add(l), this.renderRoot !== void 0 && this.isConnected && l.hostConnected?.() } removeController(l) { this._$EO?.delete(l) } _$E_() { const l = new Map, h = this.constructor.elementProperties; for (const d of h.keys()) this.hasOwnProperty(d) && (l.set(d, this[d]), delete this[d]); l.size > 0 && (this._$Ep = l) } createRenderRoot() { const l = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions); return Ln(l, this.constructor.elementStyles), l } connectedCallback() { this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach((l => l.hostConnected?.())) } enableUpdating(l) { } disconnectedCallback() { this._$EO?.forEach((l => l.hostDisconnected?.())) } attributeChangedCallback(l, h, d) { this._$AK(l, d) } _$ET(l, h) { const d = this.constructor.elementProperties.get(l), f = this.constructor._$Eu(l, d); if (f !== void 0 && d.reflect === !0) { const $ = (d.converter?.toAttribute !== void 0 ? d.converter : Ue).toAttribute(h, d.type); this._$Em = l, $ == null ? this.removeAttribute(f) : this.setAttribute(f, $), this._$Em = null } } _$AK(l, h) { const d = this.constructor, f = d._$Eh.get(l); if (f !== void 0 && this._$Em !== f) { const $ = d.getPropertyOptions(f), b = typeof $.converter == "function" ? { fromAttribute: $.converter } : $.converter?.fromAttribute !== void 0 ? $.converter : Ue; this._$Em = f; const C = b.fromAttribute(h, $.type); this[f] = C ?? this._$Ej?.get(f) ?? C, this._$Em = null } } requestUpdate(l, h, d) { if (l !== void 0) { const f = this.constructor, $ = this[l]; if (d ??= f.getPropertyOptions(l), !((d.hasChanged ?? Di)($, h) || d.useDefault && d.reflect && $ === this._$Ej?.get(l) && !this.hasAttribute(f._$Eu(l, d)))) return; this.C(l, h, d) } this.isUpdatePending === !1 && (this._$ES = this._$EP()) } C(l, h, { useDefault: d, reflect: f, wrapped: $ }, b) { d && !(this._$Ej ??= new Map).has(l) && (this._$Ej.set(l, b ?? h ?? this[l]), $ !== !0 || b !== void 0) || (this._$AL.has(l) || (this.hasUpdated || d || (h = void 0), this._$AL.set(l, h)), f === !0 && this._$Em !== l && (this._$Eq ??= new Set).add(l)) } async _$EP() { this.isUpdatePending = !0; try { await this._$ES } catch (h) { Promise.reject(h) } const l = this.scheduleUpdate(); return l != null && await l, !this.isUpdatePending } scheduleUpdate() { return this.performUpdate() } performUpdate() { if (!this.isUpdatePending) return; if (!this.hasUpdated) { if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) { for (const [f, $] of this._$Ep) this[f] = $; this._$Ep = void 0 } const d = this.constructor.elementProperties; if (d.size > 0) for (const [f, $] of d) { const { wrapped: b } = $, C = this[f]; b !== !0 || this._$AL.has(f) || C === void 0 || this.C(f, void 0, $, C) } } let l = !1; const h = this._$AL; try { l = this.shouldUpdate(h), l ? (this.willUpdate(h), this._$EO?.forEach((d => d.hostUpdate?.())), this.update(h)) : this._$EM() } catch (d) { throw l = !1, this._$EM(), d } l && this._$AE(h) } willUpdate(l) { } _$AE(l) { this._$EO?.forEach((h => h.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(l)), this.updated(l) } _$EM() { this._$AL = new Map, this.isUpdatePending = !1 } get updateComplete() { return this.getUpdateComplete() } getUpdateComplete() { return this._$ES } shouldUpdate(l) { return !0 } update(l) { this._$Eq &&= this._$Eq.forEach((h => this._$ET(h, this[h]))), this._$EM() } updated(l) { } firstUpdated(l) { } }; Qt.elementStyles = [], Qt.shadowRootOptions = { mode: "open" }, Qt[qe("elementProperties")] = new Map, Qt[qe("finalized")] = new Map, Ba?.({ ReactiveElement: Qt }), (Oi.reactiveElementVersions ??= []).push("2.1.1"); const Ss = globalThis, Ni = Ss.trustedTypes, Rn = Ni ? Ni.createPolicy("lit-html", { createHTML: p => p }) : void 0, _s = "$lit$", Bt = `lit$${Math.random().toFixed(9).slice(2)}$`, As = "?" + Bt, Ha = `<${As}>`, te = document, We = () => te.createComment(""), Ve = p => p === null || typeof p != "object" && typeof p != "function", Es = Array.isArray, qn = p => Es(p) || typeof p?.[Symbol.iterator] == "function", Cs = `[ 	
\f\r]`, Ge = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Un = /-->/g, Wn = />/g, ee = RegExp(`>|${Cs}(?:([^\\s"'>=/]+)(${Cs}*=${Cs}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Vn = /'/g, Gn = /"/g, Yn = /^(?:script|style|textarea|title)$/i, Ps = p => (l, ...h) => ({ _$litType$: p, strings: l, values: h }), za = Ps(1), La = Ps(2), Fa = Ps(3), Ht = Symbol.for("lit-noChange"), nt = Symbol.for("lit-nothing"), Xn = new WeakMap, ie = te.createTreeWalker(te, 129); function Jn(p, l) { if (!Es(p) || !p.hasOwnProperty("raw")) throw Error("invalid template strings array"); return Rn !== void 0 ? Rn.createHTML(l) : l } const Kn = (p, l) => { const h = p.length - 1, d = []; let f, $ = l === 2 ? "<svg>" : l === 3 ? "<math>" : "", b = Ge; for (let C = 0; C < h; C++) { const y = p[C]; let F, J, E = -1, x = 0; for (; x < y.length && (b.lastIndex = x, J = b.exec(y), J !== null);)x = b.lastIndex, b === Ge ? J[1] === "!--" ? b = Un : J[1] !== void 0 ? b = Wn : J[2] !== void 0 ? (Yn.test(J[2]) && (f = RegExp("</" + J[2], "g")), b = ee) : J[3] !== void 0 && (b = ee) : b === ee ? J[0] === ">" ? (b = f ?? Ge, E = -1) : J[1] === void 0 ? E = -2 : (E = b.lastIndex - J[2].length, F = J[1], b = J[3] === void 0 ? ee : J[3] === '"' ? Gn : Vn) : b === Gn || b === Vn ? b = ee : b === Un || b === Wn ? b = Ge : (b = ee, f = void 0); const H = b === ee && p[C + 1].startsWith("/>") ? " " : ""; $ += b === Ge ? y + Ha : E >= 0 ? (d.push(F), y.slice(0, E) + _s + y.slice(E) + Bt + H) : y + Bt + (E === -2 ? C : H) } return [Jn(p, $ + (p[h] || "<?>") + (l === 2 ? "</svg>" : l === 3 ? "</math>" : "")), d] }; class Ye { constructor({ strings: l, _$litType$: h }, d) { let f; this.parts = []; let $ = 0, b = 0; const C = l.length - 1, y = this.parts, [F, J] = Kn(l, h); if (this.el = Ye.createElement(F, d), ie.currentNode = this.el.content, h === 2 || h === 3) { const E = this.el.content.firstChild; E.replaceWith(...E.childNodes) } for (; (f = ie.nextNode()) !== null && y.length < C;) { if (f.nodeType === 1) { if (f.hasAttributes()) for (const E of f.getAttributeNames()) if (E.endsWith(_s)) { const x = J[b++], H = f.getAttribute(E).split(Bt), j = /([.?@])?(.*)/.exec(x); y.push({ type: 1, index: $, name: j[2], strings: H, ctor: j[1] === "." ? Qn : j[1] === "?" ? to : j[1] === "@" ? eo : Xe }), f.removeAttribute(E) } else E.startsWith(Bt) && (y.push({ type: 6, index: $ }), f.removeAttribute(E)); if (Yn.test(f.tagName)) { const E = f.textContent.split(Bt), x = E.length - 1; if (x > 0) { f.textContent = Ni ? Ni.emptyScript : ""; for (let H = 0; H < x; H++)f.append(E[H], We()), ie.nextNode(), y.push({ type: 2, index: ++$ }); f.append(E[x], We()) } } } else if (f.nodeType === 8) if (f.data === As) y.push({ type: 2, index: $ }); else { let E = -1; for (; (E = f.data.indexOf(Bt, E + 1)) !== -1;)y.push({ type: 7, index: $ }), E += Bt.length - 1 } $++ } } static createElement(l, h) { const d = te.createElement("template"); return d.innerHTML = l, d } } function se(p, l, h = p, d) { if (l === Ht) return l; let f = d !== void 0 ? h._$Co?.[d] : h._$Cl; const $ = Ve(l) ? void 0 : l._$litDirective$; return f?.constructor !== $ && (f?._$AO?.(!1), $ === void 0 ? f = void 0 : (f = new $(p), f._$AT(p, h, d)), d !== void 0 ? (h._$Co ??= [])[d] = f : h._$Cl = f), f !== void 0 && (l = se(p, f._$AS(p, l.values), f, d)), l } let Zn = class { constructor(l, h) { this._$AV = [], this._$AN = void 0, this._$AD = l, this._$AM = h } get parentNode() { return this._$AM.parentNode } get _$AU() { return this._$AM._$AU } u(l) { const { el: { content: h }, parts: d } = this._$AD, f = (l?.creationScope ?? te).importNode(h, !0); ie.currentNode = f; let $ = ie.nextNode(), b = 0, C = 0, y = d[0]; for (; y !== void 0;) { if (b === y.index) { let F; y.type === 2 ? F = new ke($, $.nextSibling, this, l) : y.type === 1 ? F = new y.ctor($, y.name, y.strings, this, l) : y.type === 6 && (F = new io($, this, l)), this._$AV.push(F), y = d[++C] } b !== y?.index && ($ = ie.nextNode(), b++) } return ie.currentNode = te, f } p(l) { let h = 0; for (const d of this._$AV) d !== void 0 && (d.strings !== void 0 ? (d._$AI(l, d, h), h += d.strings.length - 2) : d._$AI(l[h])), h++ } }; class ke { get _$AU() { return this._$AM?._$AU ?? this._$Cv } constructor(l, h, d, f) { this.type = 2, this._$AH = nt, this._$AN = void 0, this._$AA = l, this._$AB = h, this._$AM = d, this.options = f, this._$Cv = f?.isConnected ?? !0 } get parentNode() { let l = this._$AA.parentNode; const h = this._$AM; return h !== void 0 && l?.nodeType === 11 && (l = h.parentNode), l } get startNode() { return this._$AA } get endNode() { return this._$AB } _$AI(l, h = this) { l = se(this, l, h), Ve(l) ? l === nt || l == null || l === "" ? (this._$AH !== nt && this._$AR(), this._$AH = nt) : l !== this._$AH && l !== Ht && this._(l) : l._$litType$ !== void 0 ? this.$(l) : l.nodeType !== void 0 ? this.T(l) : qn(l) ? this.k(l) : this._(l) } O(l) { return this._$AA.parentNode.insertBefore(l, this._$AB) } T(l) { this._$AH !== l && (this._$AR(), this._$AH = this.O(l)) } _(l) { this._$AH !== nt && Ve(this._$AH) ? this._$AA.nextSibling.data = l : this.T(te.createTextNode(l)), this._$AH = l } $(l) { const { values: h, _$litType$: d } = l, f = typeof d == "number" ? this._$AC(l) : (d.el === void 0 && (d.el = Ye.createElement(Jn(d.h, d.h[0]), this.options)), d); if (this._$AH?._$AD === f) this._$AH.p(h); else { const $ = new Zn(f, this), b = $.u(this.options); $.p(h), this.T(b), this._$AH = $ } } _$AC(l) { let h = Xn.get(l.strings); return h === void 0 && Xn.set(l.strings, h = new Ye(l)), h } k(l) { Es(this._$AH) || (this._$AH = [], this._$AR()); const h = this._$AH; let d, f = 0; for (const $ of l) f === h.length ? h.push(d = new ke(this.O(We()), this.O(We()), this, this.options)) : d = h[f], d._$AI($), f++; f < h.length && (this._$AR(d && d._$AB.nextSibling, f), h.length = f) } _$AR(l = this._$AA.nextSibling, h) { for (this._$AP?.(!1, !0, h); l !== this._$AB;) { const d = l.nextSibling; l.remove(), l = d } } setConnected(l) { this._$AM === void 0 && (this._$Cv = l, this._$AP?.(l)) } } class Xe { get tagName() { return this.element.tagName } get _$AU() { return this._$AM._$AU } constructor(l, h, d, f, $) { this.type = 1, this._$AH = nt, this._$AN = void 0, this.element = l, this.name = h, this._$AM = f, this.options = $, d.length > 2 || d[0] !== "" || d[1] !== "" ? (this._$AH = Array(d.length - 1).fill(new String), this.strings = d) : this._$AH = nt } _$AI(l, h = this, d, f) { const $ = this.strings; let b = !1; if ($ === void 0) l = se(this, l, h, 0), b = !Ve(l) || l !== this._$AH && l !== Ht, b && (this._$AH = l); else { const C = l; let y, F; for (l = $[0], y = 0; y < $.length - 1; y++)F = se(this, C[d + y], h, y), F === Ht && (F = this._$AH[y]), b ||= !Ve(F) || F !== this._$AH[y], F === nt ? l = nt : l !== nt && (l += (F ?? "") + $[y + 1]), this._$AH[y] = F } b && !f && this.j(l) } j(l) { l === nt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, l ?? "") } } class Qn extends Xe { constructor() { super(...arguments), this.type = 3 } j(l) { this.element[this.name] = l === nt ? void 0 : l } } class to extends Xe { constructor() { super(...arguments), this.type = 4 } j(l) { this.element.toggleAttribute(this.name, !!l && l !== nt) } } class eo extends Xe { constructor(l, h, d, f, $) { super(l, h, d, f, $), this.type = 5 } _$AI(l, h = this) { if ((l = se(this, l, h, 0) ?? nt) === Ht) return; const d = this._$AH, f = l === nt && d !== nt || l.capture !== d.capture || l.once !== d.once || l.passive !== d.passive, $ = l !== nt && (d === nt || f); f && this.element.removeEventListener(this.name, this, d), $ && this.element.addEventListener(this.name, this, l), this._$AH = l } handleEvent(l) { typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, l) : this._$AH.handleEvent(l) } } class io { constructor(l, h, d) { this.element = l, this.type = 6, this._$AN = void 0, this._$AM = h, this.options = d } get _$AU() { return this._$AM._$AU } _$AI(l) { se(this, l) } } const so = { M: _s, P: Bt, A: As, C: 1, L: Kn, R: Zn, D: qn, V: se, I: ke, H: Xe, N: to, U: eo, B: Qn, F: io }, ja = Ss.litHtmlPolyfillSupport; ja?.(Ye, ke), (Ss.litHtmlVersions ??= []).push("3.3.1"); const no = (p, l, h) => { const d = h?.renderBefore ?? l; let f = d._$litPart$; if (f === void 0) { const $ = h?.renderBefore ?? null; d._$litPart$ = f = new ke(l.insertBefore(We(), $), $, void 0, h ?? {}) } return f._$AI(p), f }; const Is = globalThis; let Je = class extends Qt { constructor() { super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0 } createRenderRoot() { const l = super.createRenderRoot(); return this.renderOptions.renderBefore ??= l.firstChild, l } update(l) { const h = this.render(); this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(l), this._$Do = no(h, this.renderRoot, this.renderOptions) } connectedCallback() { super.connectedCallback(), this._$Do?.setConnected(!0) } disconnectedCallback() { super.disconnectedCallback(), this._$Do?.setConnected(!1) } render() { return Ht } }; Je._$litElement$ = !0, Je.finalized = !0, Is.litElementHydrateSupport?.({ LitElement: Je }); const Ra = Is.litElementPolyfillSupport; Ra?.({ LitElement: Je }); const qa = { _$AK: (p, l, h) => { p._$AK(l, h) }, _$AL: p => p._$AL }; (Is.litElementVersions ??= []).push("4.2.1"); const Ua = Object.freeze(Object.defineProperty({ __proto__: null, CSSResult: ys, LitElement: Je, ReactiveElement: Qt, _$LE: qa, _$LH: so, adoptStyles: Ln, css: Ca, defaultConverter: Ue, getCompatibleStyle: ks, html: za, isServer: !1, mathml: Fa, noChange: Ht, notEqual: Di, nothing: nt, render: no, supportsAdoptingStyleSheets: Mi, svg: La, unsafeCSS: zn }, Symbol.toStringTag, { value: "Module" })); const Wa = p => (l, h) => { h !== void 0 ? h.addInitializer((() => { customElements.define(p, l) })) : customElements.define(p, l) }; const Va = { attribute: !0, type: String, converter: Ue, reflect: !1, hasChanged: Di }, oo = (p = Va, l, h) => { const { kind: d, metadata: f } = h; let $ = globalThis.litPropertyMetadata.get(f); if ($ === void 0 && globalThis.litPropertyMetadata.set(f, $ = new Map), d === "setter" && ((p = Object.create(p)).wrapped = !0), $.set(h.name, p), d === "accessor") { const { name: b } = h; return { set(C) { const y = l.get.call(this); l.set.call(this, C), this.requestUpdate(b, y, p) }, init(C) { return C !== void 0 && this.C(b, void 0, p, C), C } } } if (d === "setter") { const { name: b } = h; return function (C) { const y = this[b]; l.call(this, C), this.requestUpdate(b, y, p) } } throw Error("Unsupported decorator location: " + d) }; function ro(p) { return (l, h) => typeof h == "object" ? oo(p, l, h) : ((d, f, $) => { const b = f.hasOwnProperty($); return f.constructor.createProperty($, d), b ? Object.getOwnPropertyDescriptor(f, $) : void 0 })(p, l, h) } function Ga(p) { return ro({ ...p, state: !0, attribute: !1 }) } function Ya(p) { return (l, h) => { const d = typeof l == "function" ? l : l[h]; Object.assign(d, p) } } const Se = (p, l, h) => (h.configurable = !0, h.enumerable = !0, Reflect.decorate && typeof l != "object" && Object.defineProperty(p, l, h), h); function Xa(p, l) { return (h, d, f) => { const $ = b => b.renderRoot?.querySelector(p) ?? null; if (l) { const { get: b, set: C } = typeof d == "object" ? h : f ?? (() => { const y = Symbol(); return { get() { return this[y] }, set(F) { this[y] = F } } })(); return Se(h, d, { get() { let y = b.call(this); return y === void 0 && (y = $(this), (y !== null || this.hasUpdated) && C.call(this, y)), y } }) } return Se(h, d, { get() { return $(this) } }) } } let Ja; function Ka(p) { return (l, h) => Se(l, h, { get() { return (this.renderRoot ?? (Ja ??= document.createDocumentFragment())).querySelectorAll(p) } }) } function Za(p) { return (l, h) => Se(l, h, { async get() { return await this.updateComplete, this.renderRoot?.querySelector(p) ?? null } }) } function Qa(p) { return (l, h) => { const { slot: d, selector: f } = p ?? {}, $ = "slot" + (d ? `[name=${d}]` : ":not([name])"); return Se(l, h, { get() { const b = this.renderRoot?.querySelector($), C = b?.assignedElements(p) ?? []; return f === void 0 ? C : C.filter((y => y.matches(f))) } }) } } function tl(p) { return (l, h) => { const { slot: d } = p ?? {}, f = "slot" + (d ? `[name=${d}]` : ":not([name])"); return Se(l, h, { get() { return this.renderRoot?.querySelector(f)?.assignedNodes(p) ?? [] } }) } } const el = Object.freeze(Object.defineProperty({ __proto__: null, customElement: Wa, eventOptions: Ya, property: ro, query: Xa, queryAll: Ka, queryAssignedElements: Qa, queryAssignedNodes: tl, queryAsync: Za, standardProperty: oo, state: Ga }, Symbol.toStringTag, { value: "Module" })); const ao = { CHILD: 2 }, lo = p => (...l) => ({ _$litDirective$: p, values: l }); class co { constructor(l) { } get _$AU() { return this._$AM._$AU } _$AT(l, h, d) { this._$Ct = l, this._$AM = h, this._$Ci = d } _$AS(l, h) { return this.update(l, h) } update(l, h) { return this.render(...h) } } const { I: il } = so, ho = () => document.createComment(""), Ke = (p, l, h) => { const d = p._$AA.parentNode, f = l === void 0 ? p._$AB : l._$AA; if (h === void 0) { const $ = d.insertBefore(ho(), f), b = d.insertBefore(ho(), f); h = new il($, b, p, p.options) } else { const $ = h._$AB.nextSibling, b = h._$AM, C = b !== p; if (C) { let y; h._$AQ?.(p), h._$AM = p, h._$AP !== void 0 && (y = p._$AU) !== b._$AU && h._$AP(y) } if ($ !== f || C) { let y = h._$AA; for (; y !== $;) { const F = y.nextSibling; d.insertBefore(y, f), y = F } } } return h }, ne = (p, l, h = p) => (p._$AI(l, h), p), sl = {}, nl = (p, l = sl) => p._$AH = l, ol = p => p._$AH, Ts = p => { p._$AR(), p._$AA.remove() }; const uo = (p, l, h) => { const d = new Map; for (let f = l; f <= h; f++)d.set(p[f], f); return d }, rl = lo(class extends co { constructor(p) { if (super(p), p.type !== ao.CHILD) throw Error("repeat() can only be used in text expressions") } dt(p, l, h) { let d; h === void 0 ? h = l : l !== void 0 && (d = l); const f = [], $ = []; let b = 0; for (const C of p) f[b] = d ? d(C, b) : b, $[b] = h(C, b), b++; return { values: $, keys: f } } render(p, l, h) { return this.dt(p, l, h).values } update(p, [l, h, d]) { const f = ol(p), { values: $, keys: b } = this.dt(l, h, d); if (!Array.isArray(f)) return this.ut = b, $; const C = this.ut ??= [], y = []; let F, J, E = 0, x = f.length - 1, H = 0, j = $.length - 1; for (; E <= x && H <= j;)if (f[E] === null) E++; else if (f[x] === null) x--; else if (C[E] === b[H]) y[H] = ne(f[E], $[H]), E++, H++; else if (C[x] === b[j]) y[j] = ne(f[x], $[j]), x--, j--; else if (C[E] === b[j]) y[j] = ne(f[E], $[j]), Ke(p, y[j + 1], f[E]), E++, j--; else if (C[x] === b[H]) y[H] = ne(f[x], $[H]), Ke(p, f[E], f[x]), x--, H++; else if (F === void 0 && (F = uo(b, H, j), J = uo(C, E, x)), F.has(C[E])) if (F.has(C[x])) { const pt = J.get(b[H]), bt = pt !== void 0 ? f[pt] : null; if (bt === null) { const gt = Ke(p, f[E]); ne(gt, $[H]), y[H] = gt } else y[H] = ne(bt, $[H]), Ke(p, f[E], bt), f[pt] = null; H++ } else Ts(f[x]), x--; else Ts(f[E]), E++; for (; H <= j;) { const pt = Ke(p, y[j + 1]); ne(pt, $[H]), y[H++] = pt } for (; E <= x;) { const pt = f[E++]; pt !== null && Ts(pt) } return this.ut = b, nl(p, y), Ht } }); class Ms extends co { constructor(l) { if (super(l), this.it = nt, l.type !== ao.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings") } render(l) { if (l === nt || l == null) return this._t = void 0, this.it = l; if (l === Ht) return l; if (typeof l != "string") throw Error(this.constructor.directiveName + "() called with a non-string value"); if (l === this.it) return this._t; this.it = l; const h = [l]; return h.raw = h, this._t = { _$litType$: this.constructor.resultType, strings: h, values: [] } } } Ms.directiveName = "unsafeHTML", Ms.resultType = 1; const al = lo(Ms); function ll(p) { return p && p.__esModule && Object.prototype.hasOwnProperty.call(p, "default") ? p.default : p } var Bi = { exports: {} }; var cl = Bi.exports, fo; function hl() { return fo || (fo = 1, (function (p, l) { (function (h, d) { p.exports = d() })(cl, (function () { const { hasOwnProperty: h, toString: d } = Object.prototype; function f(t, e) { return h.call(t, e) } const $ = /\B([A-Z])/g, b = Et(t => t.replace($, "-$1").toLowerCase()), C = /-(\w)/g, y = Et(t => (t.charAt(0).toLowerCase() + t.slice(1)).replace(C, (e, i) => i.toUpperCase())), F = Et(t => t.charAt(0).toUpperCase() + t.slice(1)); function J(t, e) { var i; return (i = t?.startsWith) == null ? void 0 : i.call(t, e) } function E(t, e) { var i; return (i = t?.endsWith) == null ? void 0 : i.call(t, e) } function x(t, e) { var i; return (i = t?.includes) == null ? void 0 : i.call(t, e) } function H(t, e) { var i; return (i = t?.findIndex) == null ? void 0 : i.call(t, e) } const { isArray: j, from: pt } = Array, { assign: bt } = Object; function gt(t) { return typeof t == "function" } function Ut(t) { return t !== null && typeof t == "object" } function Ze(t) { return d.call(t) === "[object Object]" } function Hi(t) { return Ut(t) && t === t.window } function Qe(t) { return Os(t) === 9 } function ti(t) { return Os(t) >= 1 } function _e(t) { return Os(t) === 1 } function Os(t) { return !Hi(t) && Ut(t) && t.nodeType } function Ae(t) { return typeof t == "boolean" } function tt(t) { return typeof t == "string" } function ei(t) { return typeof t == "number" } function Mt(t) { return ei(t) || tt(t) && !isNaN(t - parseFloat(t)) } function zi(t) { return !(j(t) ? t.length : Ut(t) && Object.keys(t).length) } function dt(t) { return t === void 0 } function Ds(t) { return Ae(t) ? t : t === "true" || t === "1" || t === "" ? !0 : t === "false" || t === "0" ? !1 : t } function zt(t) { const e = Number(t); return isNaN(e) ? !1 : e } function N(t) { return parseFloat(t) || 0 } function ot(t) { return t && z(t)[0] } function z(t) { return ti(t) ? [t] : Array.from(t || []).filter(ti) } function oe(t) { if (Hi(t)) return t; t = ot(t); const e = Qe(t) ? t : t?.ownerDocument; return e?.defaultView || window } function ii(t, e) { return t === e || Ut(t) && Ut(e) && Object.keys(t).length === Object.keys(e).length && Ee(t, (i, s) => i === e[s]) } function Ns(t, e, i) { return t.replace(new RegExp(`${e}|${i}`, "g"), s => s === e ? i : e) } function re(t) { return t[t.length - 1] } function Ee(t, e) { for (const i in t) if (e(t[i], i) === !1) return !1; return !0 } function po(t, e) { return t.slice().sort(({ [e]: i = 0 }, { [e]: s = 0 }) => i > s ? 1 : s > i ? -1 : 0) } function ae(t, e) { return t.reduce((i, s) => i + N(gt(e) ? e(s) : s[e]), 0) } function go(t, e) { const i = new Set; return t.filter(({ [e]: s }) => i.has(s) ? !1 : i.add(s)) } function Li(t, e) { return e.reduce((i, s) => ({ ...i, [s]: t[s] }), {}) } function rt(t, e = 0, i = 1) { return Math.min(Math.max(zt(t) || 0, e), i) } function U() { } function Fi(...t) { return [["bottom", "top"], ["right", "left"]].every(([e, i]) => Math.min(...t.map(({ [e]: s }) => s)) - Math.max(...t.map(({ [i]: s }) => s)) > 0) } function ji(t, e) { return t.x <= e.right && t.x >= e.left && t.y <= e.bottom && t.y >= e.top } function Bs(t, e, i) { const s = e === "width" ? "height" : "width"; return { [s]: t[e] ? Math.round(i * t[s] / t[e]) : t[s], [e]: i } } function mo(t, e) { t = { ...t }; for (const i in t) t = t[i] > e[i] ? Bs(t, i, e[i]) : t; return t } function fl(t, e) { t = mo(t, e); for (const i in t) t = t[i] < e[i] ? Bs(t, i, e[i]) : t; return t } const Hs = { ratio: Bs, contain: mo, cover: fl }; function kt(t, e, i = 0, s = !1) { e = z(e); const { length: n } = e; return n ? (t = Mt(t) ? zt(t) : t === "next" ? i + 1 : t === "previous" ? i - 1 : t === "last" ? n - 1 : e.indexOf(ot(t)), s ? rt(t, 0, n - 1) : (t %= n, t < 0 ? t + n : t)) : -1 } function Et(t) { const e = Object.create(null); return (i, ...s) => e[i] || (e[i] = t(i, ...s)) } function B(t, ...e) { for (const i of z(t)) { const s = le(e).filter(n => !T(i, n)); s.length && i.classList.add(...s) } } function q(t, ...e) { for (const i of z(t)) { const s = le(e).filter(n => T(i, n)); s.length && i.classList.remove(...s) } } function Ri(t, e, i) { i = le(i), e = le(e).filter(s => !x(i, s)), q(t, e), B(t, i) } function T(t, e) { return [e] = le(e), z(t).some(i => i.classList.contains(e)) } function Z(t, e, i) { const s = le(e); dt(i) || (i = !!i); for (const n of z(t)) for (const o of s) n.classList.toggle(o, i) } function le(t) { return t ? j(t) ? t.map(le).flat() : String(t).split(" ").filter(Boolean) : [] } function O(t, e, i) { var s; if (Ut(e)) { for (const n in e) O(t, n, e[n]); return } if (dt(i)) return (s = ot(t)) == null ? void 0 : s.getAttribute(e); for (const n of z(t)) gt(i) && (i = i.call(n, O(n, e))), i === null ? si(n, e) : n.setAttribute(e, i) } function Lt(t, e) { return z(t).some(i => i.hasAttribute(e)) } function si(t, e) { z(t).forEach(i => i.removeAttribute(e)) } function mt(t, e) { for (const i of [e, `data-${e}`]) if (Lt(t, i)) return O(t, i) } const ce = typeof window < "u", at = ce && document.dir === "rtl", Ce = ce && "ontouchstart" in window, Pe = ce && window.PointerEvent, Ct = Pe ? "pointerdown" : Ce ? "touchstart" : "mousedown", ni = Pe ? "pointermove" : Ce ? "touchmove" : "mousemove", Wt = Pe ? "pointerup" : Ce ? "touchend" : "mouseup", Vt = Pe ? "pointerenter" : Ce ? "" : "mouseenter", Gt = Pe ? "pointerleave" : Ce ? "" : "mouseleave", qi = Pe ? "pointercancel" : "touchcancel", pl = { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }; function zs(t) { return z(t).some(e => pl[e.tagName.toLowerCase()]) } const gl = ce && Element.prototype.checkVisibility || function () { return this.offsetWidth || this.offsetHeight || this.getClientRects().length }; function et(t) { return z(t).some(e => gl.call(e)) } const oi = "input,select,textarea,button"; function Ui(t) { return z(t).some(e => R(e, oi)) } const Ie = `${oi},a[href],[tabindex]`; function ri(t) { return R(t, Ie) } function W(t) { var e; return (e = ot(t)) == null ? void 0 : e.parentElement } function ai(t, e) { return z(t).filter(i => R(i, e)) } function R(t, e) { return z(t).some(i => i.matches(e)) } function Te(t, e) { const i = []; for (; t = W(t);)(!e || R(t, e)) && i.push(t); return i } function X(t, e) { t = ot(t); const i = t ? pt(t.children) : []; return e ? ai(i, e) : i } function Ft(t, e) { return e ? z(t).indexOf(ot(e)) : X(W(t)).indexOf(t) } function Me(t) { return t = ot(t), t && ["origin", "pathname", "search"].every(e => t[e] === location[e]) } function Wi(t) { if (Me(t)) { const { hash: e, ownerDocument: i } = ot(t), s = decodeURIComponent(e).slice(1); return s ? i.getElementById(s) || i.getElementsByName(s)[0] : i.documentElement } } function ft(t, e) { return Ls(t, vo(t, e)) } function li(t, e) { return ci(t, vo(t, e)) } function Ls(t, e) { return ot(wo(t, ot(e), "querySelector")) } function ci(t, e) { return z(wo(t, ot(e), "querySelectorAll")) } function vo(t, e = document) { return Qe(e) || $o(t).isContextSelector ? e : e.ownerDocument } const ml = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g, vl = /(\([^)]*\)|[^,])+/g, $o = Et(t => { let e = !1; if (!t || !tt(t)) return {}; const i = []; for (let s of t.match(vl)) s = s.trim().replace(ml, "$1 *"), e || (e = ["!", "+", "~", "-", ">"].includes(s[0])), i.push(s); return { selector: i.join(","), selectors: i, isContextSelector: e } }), $l = /(\([^)]*\)|\S)*/, bo = Et(t => { t = t.slice(1).trim(); const [e] = t.match($l); return [e, t.slice(e.length + 1)] }); function wo(t, e = document, i) { var s; const n = $o(t); if (!n.isContextSelector) return n.selector ? Fs(e, i, n.selector) : t; t = ""; const o = n.selectors.length === 1; for (let r of n.selectors) { let a, c = e; if (r[0] === "!" && ([a, r] = bo(r), c = (s = e.parentElement) == null ? void 0 : s.closest(a), !r && o) || c && r[0] === "-" && ([a, r] = bo(r), c = c.previousElementSibling, c = R(c, a) ? c : null, !r && o)) return c; if (c) { if (o) return r[0] === "~" || r[0] === "+" ? (r = `:scope > :nth-child(${Ft(c) + 1}) ${r}`, c = c.parentElement) : r[0] === ">" && (r = `:scope ${r}`), Fs(c, i, r); t += `${t ? "," : ""}${bl(c)} ${r}` } } return Qe(e) || (e = e.ownerDocument), Fs(e, i, t) } function Fs(t, e, i) { try { return t[e](i) } catch { return null } } function bl(t) { const e = []; for (; t.parentNode;) { const i = O(t, "id"); if (i) { e.unshift(`#${js(i)}`); break } else { let { tagName: s } = t; s !== "HTML" && (s += `:nth-child(${Ft(t) + 1})`), e.unshift(s), t = t.parentNode } } return e.join(" > ") } function js(t) { return tt(t) ? CSS.escape(t) : "" } function P(...t) { let [e, i, s, n, o = !1] = Rs(t); n.length > 1 && (n = xl(n)), o?.self && (n = yl(n)), s && (n = wl(s, n)); for (const r of i) for (const a of e) a.addEventListener(r, n, o); return () => he(e, i, n, o) } function he(...t) { let [e, i, , s, n = !1] = Rs(t); for (const o of i) for (const r of e) r.removeEventListener(o, s, n) } function K(...t) { const [e, i, s, n, o = !1, r] = Rs(t), a = P(e, i, s, c => { const g = !r || r(c); g && (a(), n(c, g)) }, o); return a } function _(t, e, i) { return qs(t).every(s => s.dispatchEvent(Oe(e, !0, !0, i))) } function Oe(t, e = !0, i = !1, s) { return tt(t) && (t = new CustomEvent(t, { bubbles: e, cancelable: i, detail: s })), t } function Rs(t) { return t[0] = qs(t[0]), tt(t[1]) && (t[1] = t[1].split(" ")), gt(t[2]) && t.splice(2, 0, !1), t } function wl(t, e) { return i => { const s = t[0] === ">" ? ci(t, i.currentTarget).reverse().find(n => n.contains(i.target)) : i.target.closest(t); s && (i.current = s, e.call(this, i), delete i.current) } } function xl(t) { return e => j(e.detail) ? t(e, ...e.detail) : t(e) } function yl(t) { return function (e) { if (e.target === e.currentTarget || e.target === e.current) return t.call(null, e) } } function xo(t) { return t && "addEventListener" in t } function kl(t) { return xo(t) ? t : ot(t) } function qs(t) { return j(t) ? t.map(kl).filter(Boolean) : tt(t) ? ci(t) : xo(t) ? [t] : z(t) } function It(t) { return t.pointerType === "touch" || !!t.touches } function jt(t) { var e, i; const { clientX: s, clientY: n } = ((e = t.touches) == null ? void 0 : e[0]) || ((i = t.changedTouches) == null ? void 0 : i[0]) || t; return { x: s, y: n } } const Sl = { "animation-iteration-count": !0, "column-count": !0, "fill-opacity": !0, "flex-grow": !0, "flex-shrink": !0, "font-weight": !0, "line-height": !0, opacity: !0, order: !0, orphans: !0, "stroke-dasharray": !0, "stroke-dashoffset": !0, widows: !0, "z-index": !0, zoom: !0 }; function u(t, e, i, s) { const n = z(t); for (const o of n) if (tt(e)) { if (e = Vi(e), dt(i)) return getComputedStyle(o).getPropertyValue(e); o.style.setProperty(e, Mt(i) && !Sl[e] && !yo(e) ? `${i}px` : i || ei(i) ? i : "", s) } else if (j(e)) { const r = {}; for (const a of e) r[a] = u(o, a); return r } else if (Ut(e)) for (const r in e) u(o, r, e[r], i); return n[0] } function Ot(t, e) { for (const i in e) u(t, i, "") } const Vi = Et(t => { if (yo(t)) return t; t = b(t); const { style: e } = document.documentElement; if (t in e) return t; for (const i of ["webkit", "moz"]) { const s = `-${i}-${t}`; if (s in e) return s } }); function yo(t) { return J(t, "--") } const Us = "uk-transition", Ws = "transitionend", Vs = "transitioncanceled"; function _l(t, e, i = 400, s = "linear", n) { return i = Math.round(i), Promise.all(z(t).map(o => new Promise((r, a) => { n || o.offsetHeight; const c = setTimeout(() => _(o, Ws), i); K(o, [Ws, Vs], ({ type: m }) => { clearTimeout(c), q(o, Us), Ot(o, g), m === Vs ? a() : r(o) }, { self: !0 }), B(o, Us); const g = { transitionProperty: Object.keys(e).map(Vi).join(","), transitionDuration: `${i}ms`, transitionTimingFunction: s }; u(o, { ...g, ...e }) }))) } const V = { start: _l, async stop(t) { _(t, Ws), await Promise.resolve() }, async cancel(t) { _(t, Vs), await Promise.resolve() }, inProgress(t) { return T(t, Us) } }, hi = "uk-animation", ko = "animationend", Gi = "animationcanceled"; function So(t, e, i = 200, s, n) { return Promise.all(z(t).map(o => new Promise((r, a) => { T(o, hi) && _(o, Gi); const c = [e, hi, `${hi}-${n ? "leave" : "enter"}`, s && `uk-transform-origin-${s}`, n && `${hi}-reverse`], g = setTimeout(() => _(o, ko), i); K(o, [ko, Gi], ({ type: m }) => { clearTimeout(g), m === Gi ? a() : r(o), u(o, "animationDuration", ""), q(o, c) }, { self: !0 }), u(o, "animationDuration", `${i}ms`), B(o, c) }))) } const Yt = { in: So, out(t, e, i, s) { return So(t, e, i, s, !0) }, inProgress(t) { return T(t, hi) }, cancel(t) { _(t, Gi) } }; function Al(t) { if (document.readyState !== "loading") { t(); return } K(document, "DOMContentLoaded", t) } function Q(t, ...e) { return e.some(i => { var s; return ((s = t?.tagName) == null ? void 0 : s.toLowerCase()) === i.toLowerCase() }) } function _o(t) { return t = I(t), t && (t.innerHTML = ""), t } function Dt(t, e) { return dt(e) ? I(t).innerHTML : it(_o(t), e) } const El = Ji("prepend"), it = Ji("append"), Yi = Ji("before"), Xi = Ji("after"); function Ji(t) { return function (e, i) { var s; const n = z(tt(i) ? Rt(i) : i); return (s = I(e)) == null || s[t](...n), Ao(n) } } function vt(t) { z(t).forEach(e => e.remove()) } function ui(t, e) { for (e = ot(Yi(t, e)); e.firstElementChild;)e = e.firstElementChild; return it(e, t), e } function Gs(t, e) { return z(z(t).map(i => i.hasChildNodes() ? ui(pt(i.childNodes), e) : it(i, e))) } function di(t) { z(t).map(W).filter((e, i, s) => s.indexOf(e) === i).forEach(e => e.replaceWith(...e.childNodes)) } const Cl = /^<(\w+)\s*\/?>(?:<\/\1>)?$/; function Rt(t) { const e = Cl.exec(t); if (e) return document.createElement(e[1]); const i = document.createElement("template"); return i.innerHTML = t.trim(), Ao(i.content.childNodes) } function Ao(t) { return t.length > 1 ? t : t[0] } function Xt(t, e) { if (_e(t)) for (e(t), t = t.firstElementChild; t;)Xt(t, e), t = t.nextElementSibling } function I(t, e) { return Eo(t) ? ot(Rt(t)) : Ls(t, e) } function G(t, e) { return Eo(t) ? z(Rt(t)) : ci(t, e) } function Eo(t) { return tt(t) && J(t.trim(), "<") } const ue = { width: ["left", "right"], height: ["top", "bottom"] }; function S(t) { const e = _e(t) ? ot(t).getBoundingClientRect() : { height: $t(t), width: Ki(t), top: 0, left: 0 }; return { height: e.height, width: e.width, top: e.top, left: e.left, bottom: e.top + e.height, right: e.left + e.width } } function L(t, e) { e && u(t, { left: 0, top: 0 }); const i = S(t); if (t) { const { scrollY: s, scrollX: n } = oe(t), o = { height: s, width: n }; for (const r in ue) for (const a of ue[r]) i[a] += o[r] } if (!e) return i; for (const s of ["left", "top"]) u(t, s, e[s] - i[s]) } function Ys(t) { let { top: e, left: i } = L(t); const { ownerDocument: { body: s, documentElement: n }, offsetParent: o } = ot(t); let r = o || n; for (; r && (r === s || r === n) && u(r, "position") === "static";)r = r.parentNode; if (_e(r)) { const a = L(r); e -= a.top + N(u(r, "borderTopWidth")), i -= a.left + N(u(r, "borderLeftWidth")) } return { top: e - N(u(t, "marginTop")), left: i - N(u(t, "marginLeft")) } } function fi(t) { t = ot(t); const e = [t.offsetTop, t.offsetLeft]; for (; t = t.offsetParent;)if (e[0] += t.offsetTop + N(u(t, "borderTopWidth")), e[1] += t.offsetLeft + N(u(t, "borderLeftWidth")), u(t, "position") === "fixed") { const i = oe(t); return e[0] += i.scrollY, e[1] += i.scrollX, e } return e } const $t = Co("height"), Ki = Co("width"); function Co(t) { const e = F(t); return (i, s) => { if (dt(s)) { if (Hi(i)) return i[`inner${e}`]; if (Qe(i)) { const n = i.documentElement; return Math.max(n[`offset${e}`], n[`scroll${e}`]) } return i = ot(i), s = u(i, t), s = s === "auto" ? i[`offset${e}`] : N(s) || 0, s - De(i, t) } else return u(i, t, !s && s !== 0 ? "" : +s + De(i, t) + "px") } } function De(t, e, i = "border-box") { return u(t, "boxSizing") === i ? ae(ue[e], s => N(u(t, `padding-${s}`)) + N(u(t, `border-${s}-width`))) : 0 } function Zi(t) { for (const e in ue) for (const i in ue[e]) if (ue[e][i] === t) return ue[e][1 - i]; return t } function ht(t, e = "width", i = window, s = !1) { return tt(t) ? ae(Il(t), n => { const o = Ml(n); return o ? Ol(o === "vh" ? Dl() : o === "vw" ? Ki(oe(i)) : s ? i[`offset${F(e)}`] : S(i)[e], n) : n }) : N(t) } const Pl = /-?\d+(?:\.\d+)?(?:v[wh]|%|px)?/g, Il = Et(t => t.toString().replace(/\s/g, "").match(Pl) || []), Tl = /(?:v[hw]|%)$/, Ml = Et(t => (t.match(Tl) || [])[0]); function Ol(t, e) { return t * N(e) / 100 } let pi, Ne; function Dl() { return pi || (Ne || (Ne = I("<div>"), u(Ne, { height: "100vh", position: "fixed" }), P(window, "resize", () => pi = null)), it(document.body, Ne), pi = Ne.clientHeight, vt(Ne), pi) } const Jt = { read: Nl, write: Bl, clear: Hl, flush: Po }, Qi = [], ts = []; function Nl(t) { return Qi.push(t), Js(), t } function Bl(t) { return ts.push(t), Js(), t } function Hl(t) { To(Qi, t), To(ts, t) } let Xs = !1; function Po() { Io(Qi), Io(ts.splice(0)), Xs = !1, (Qi.length || ts.length) && Js() } function Js() { Xs || (Xs = !0, queueMicrotask(Po)) } function Io(t) { let e; for (; e = t.shift();)try { e() } catch (i) { console.error(i) } } function To(t, e) { const i = t.indexOf(e); return ~i && t.splice(i, 1) } class Mo { init() { this.positions = []; let e; this.unbind = P(document, "mousemove", i => e = jt(i)), this.interval = setInterval(() => { e && (this.positions.push(e), this.positions.length > 5 && this.positions.shift()) }, 50) } cancel() { var e; (e = this.unbind) == null || e.call(this), clearInterval(this.interval) } movesTo(e) { if (!this.positions || this.positions.length < 2) return !1; const i = S(e), { left: s, right: n, top: o, bottom: r } = i, [a] = this.positions, c = re(this.positions), g = [a, c]; return ji(c, i) ? !1 : [[{ x: s, y: o }, { x: n, y: r }], [{ x: s, y: r }, { x: n, y: o }]].some(v => { const w = zl(g, v); return w && ji(w, i) }) } } function zl([{ x: t, y: e }, { x: i, y: s }], [{ x: n, y: o }, { x: r, y: a }]) { const c = (a - o) * (i - t) - (r - n) * (s - e); if (c === 0) return !1; const g = ((r - n) * (e - o) - (a - o) * (t - n)) / c; return g < 0 ? !1 : { x: t + g * (i - t), y: e + g * (s - e) } } function Oo(t, e, i = {}, { intersecting: s = !0 } = {}) { const n = new IntersectionObserver(s ? (o, r) => { o.some(a => a.isIntersecting) && e(o, r) } : e, i); for (const o of z(t)) n.observe(o); return n } const Ll = ce && window.ResizeObserver; function gi(t, e, i = { box: "border-box" }) { if (Ll) return Do(ResizeObserver, t, e, i); const s = [P(window, "load resize", e), P(document, "loadedmetadata load", e, !0)]; return { disconnect: () => s.map(n => n()) } } function Ks(t) { return { disconnect: P([window, window.visualViewport], "resize", t) } } function Zs(t, e, i) { return Do(MutationObserver, t, e, i) } function Do(t, e, i, s) { const n = new t(i); for (const o of z(e)) n.observe(o, s); return n } function Qs(t) { en(t) && sn(t, { func: "playVideo", method: "play" }), tn(t) && t.play().catch(U) } function No(t) { en(t) && t[es] && sn(t, { func: "pauseVideo", method: "pause" }), tn(t) && t.pause() } function Bo(t) { en(t) && sn(t, { func: "mute", method: "setVolume", value: 0 }), tn(t) && (t.muted = !0) } function tn(t) { return Q(t, "video") } function en(t) { return Q(t, "iframe") && (Ho(t) || zo(t)) } function Ho(t) { return !!t.src.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/) } function zo(t) { return !!t.src.match(/vimeo\.com\/video\/.*/) } async function sn(t, e) { await jl(t), Lo(t, e) } function Lo(t, e) { t.contentWindow.postMessage(JSON.stringify({ event: "command", ...e }), "*") } const es = "_ukPlayer"; let Fl = 0; function jl(t) { if (t[es]) return t[es]; const e = Ho(t), i = zo(t), s = ++Fl; let n; return t[es] = new Promise(o => { e && K(t, "load", () => { const r = () => Lo(t, { event: "listening", id: s }); n = setInterval(r, 100), r() }), K(window, "message", o, !1, ({ data: r }) => { try { return r = JSON.parse(r), e && r?.id === s && r.event === "onReady" || i && Number(r?.player_id) === s } catch { } }), t.src = `${t.src}${x(t.src, "?") ? "&" : "?"}${e ? "enablejsapi=1" : `api=1&player_id=${s}`}` }).then(() => clearInterval(n)) } function mi(t, e = 0, i = 0) { return et(t) ? Fi(...fe(t).map(s => { const { top: n, left: o, bottom: r, right: a } = xt(s); return { top: n - e, left: o - i, bottom: r + e, right: a + i } }).concat(L(t))) : !1 } function Fo(t, { offset: e = 0 } = {}) { const i = et(t) ? de(t, !1, ["hidden"]) : []; return i.reduce((r, a, c) => { const { scrollTop: g, scrollHeight: m, offsetHeight: v } = a, w = xt(a), A = m - w.height, { height: M, top: k } = i[c - 1] ? xt(i[c - 1]) : L(t); let D = Math.ceil(k - w.top - e + g); return e > 0 && v < M + e ? D += e : e = 0, D > A ? (e -= D - A, D = A) : D < 0 && (e -= D, D = 0), () => s(a, D - g, t, A).then(r) }, () => Promise.resolve())(); function s(r, a, c, g) { return new Promise(m => { const v = r.scrollTop, w = n(Math.abs(a)), A = Date.now(), M = rn(r) === r, k = L(c).top + (M ? 0 : v); let D = 0, ut = 15; (function Tt() { const Nt = o(rt((Date.now() - A) / w)); let Pt = 0; i[0] === r && v + a < g && (Pt = L(c).top + (M ? 0 : r.scrollTop) - k - S(nn(c)).height), u(r, "scrollBehavior") !== "auto" && u(r, "scrollBehavior", "auto"), r.scrollTop = v + (a + Pt) * Nt, u(r, "scrollBehavior", ""), Nt === 1 && (D === Pt || !ut--) ? m() : (D = Pt, requestAnimationFrame(Tt)) })() }) } function n(r) { return 40 * Math.pow(r, .375) } function o(r) { return .5 * (1 - Math.cos(Math.PI * r)) } } function is(t, e = 0, i = 0) { if (!et(t)) return 0; const s = Kt(t, !0), { scrollHeight: n, scrollTop: o } = s, { height: r } = xt(s), a = n - r, c = fi(t)[0] - fi(s)[0], g = Math.max(0, c - r + e), m = Math.min(a, c + t.offsetHeight - i); return g < m ? rt((o - g) / (m - g)) : 1 } function de(t, e = !1, i = []) { const s = rn(t); let n = Te(t).reverse(); n = n.slice(n.indexOf(s) + 1); const o = H(n, r => u(r, "position") === "fixed"); return ~o && (n = n.slice(o)), [s].concat(n.filter(r => u(r, "overflow").split(" ").some(a => x(["auto", "scroll", ...i], a)) && (!e || r.scrollHeight > xt(r).height))).reverse() } function Kt(...t) { return de(...t)[0] } function fe(t) { return de(t, !1, ["hidden", "clip"]) } function xt(t) { const e = oe(t), i = rn(t), s = !ti(t) || t.contains(i); if (s && e.visualViewport) { let { height: c, width: g, scale: m, pageTop: v, pageLeft: w } = e.visualViewport; return c = Math.round(c * m), g = Math.round(g * m), { height: c, width: g, top: v, left: w, bottom: v + c, right: w + g } } let n = L(s ? e : t); if (u(t, "display") === "inline") return n; const { body: o, documentElement: r } = e.document, a = s ? i === r || i.clientHeight < o.clientHeight ? i : o : t; for (let [c, g, m, v] of [["width", "x", "left", "right"], ["height", "y", "top", "bottom"]]) { const w = n[c] % 1; n[m] += N(u(a, `border-${m}-width`)), n[c] = n[g] = a[`client${F(c)}`] - (w ? w < .5 ? -w : 1 - w : 0), n[v] = n[c] + n[m] } return n } function nn(t) { const { document: e } = oe(t); t = t || e.body; const { left: i, width: s, top: n } = S(t); for (const o of n ? [0, n] : [0]) { let r; for (const a of e.elementsFromPoint(i + s / 2, o)) !a.contains(t) && !T(a, "uk-togglable-leave") && (on(a, "fixed") && jo(Te(t).reverse().find(c => !c.contains(a) && !on(c, "static"))) < jo(a) || on(a, "sticky") && (!t || W(a).contains(t))) && (!r || S(r).height < S(a).height) && (r = a); if (r) return r } } function jo(t) { return N(u(t, "zIndex")) } function on(t, e) { return u(t, "position") === e } function rn(t) { return oe(t).document.scrollingElement } const St = [["width", "x", "left", "right"], ["height", "y", "top", "bottom"]]; function Ro(t, e, i) { i = { attach: { element: ["left", "top"], target: ["left", "top"], ...i.attach }, offset: [0, 0], placement: [], ...i }, j(e) || (e = [e, e]), L(t, qo(t, e, i)) } function qo(t, e, i) { const s = Uo(t, e, i), { boundary: n, viewportOffset: o = 0, placement: r } = i; let a = s; for (const [c, [g, , m, v]] of Object.entries(St)) { const w = Rl(t, e[c], o, n, c); if (ss(s, w, c)) continue; let A = 0; if (r[c] === "flip") { const M = i.attach.target[c]; if (M === v && s[v] <= w[v] || M === m && s[m] >= w[m]) continue; A = Ul(t, e, i, c)[m] - s[m]; const k = ql(t, e[c], o, c); if (!ss(an(s, A, c), k, c)) { if (ss(s, k, c)) continue; if (i.recursion) return !1; const D = Wl(t, e, i); if (D && ss(D, k, 1 - c)) return D; continue } } else if (r[c] === "shift") { const M = L(e[c]), { offset: k } = i; A = rt(rt(s[m], w[m], w[v] - s[g]), M[m] - s[g] + k[c], M[v] - k[c]) - s[m] } a = an(a, A, c) } return a } function Uo(t, e, i) { let { attach: s, offset: n } = { attach: { element: ["left", "top"], target: ["left", "top"], ...i.attach }, offset: [0, 0], ...i }, o = L(t); for (const [r, [a, , c, g]] of Object.entries(St)) { const m = s.target[r] === s.element[r] ? xt(e[r]) : L(e[r]); o = an(o, m[c] - o[c] + Wo(s.target[r], g, m[a]) - Wo(s.element[r], g, o[a]) + +n[r], r) } return o } function an(t, e, i) { const [, s, n, o] = St[i], r = { ...t }; return r[n] = t[s] = t[n] + e, r[o] += e, r } function Wo(t, e, i) { return t === "center" ? i / 2 : t === e ? i : 0 } function Rl(t, e, i, s, n) { let o = Go(...Vo(t, e).map(xt)); return i && (o[St[n][2]] += i, o[St[n][3]] -= i), s && (o = Go(o, L(j(s) ? s[n] : s))), o } function ql(t, e, i, s) { const [n, o, r, a] = St[s], [c] = Vo(t, e), g = xt(c); return ["auto", "scroll"].includes(u(c, `overflow-${o}`)) && (g[r] -= c[`scroll${F(r)}`], g[a] = g[r] + c[`scroll${F(n)}`]), g[r] += i, g[a] -= i, g } function Vo(t, e) { return fe(e).filter(i => i.contains(t)) } function Go(...t) { let e = {}; for (const i of t) for (const [, , s, n] of St) e[s] = Math.max(e[s] || 0, i[s]), e[n] = Math.min(...[e[n], i[n]].filter(Boolean)); return e } function ss(t, e, i) { const [, , s, n] = St[i]; return t[s] >= e[s] && t[n] <= e[n] } function Ul(t, e, { offset: i, attach: s }, n) { return Uo(t, e, { attach: { element: Yo(s.element, n), target: Yo(s.target, n) }, offset: Vl(i, n) }) } function Wl(t, e, i) { return qo(t, e, { ...i, attach: { element: i.attach.element.map(Xo).reverse(), target: i.attach.target.map(Xo).reverse() }, offset: i.offset.reverse(), placement: i.placement.reverse(), recursion: !0 }) } function Yo(t, e) { const i = [...t], s = St[e].indexOf(t[e]); return ~s && (i[e] = St[e][1 - s % 2 + 2]), i } function Xo(t) { for (let e = 0; e < St.length; e++) { const i = St[e].indexOf(t); if (~i) return St[1 - e][i % 2 + 2] } } function Vl(t, e) { return t = [...t], t[e] *= -1, t } var Gl = Object.freeze({ __proto__: null, $: I, $$: G, Animation: Yt, Dimensions: Hs, MouseTracker: Mo, Transition: V, addClass: B, after: Xi, append: it, apply: Xt, assign: bt, attr: O, before: Yi, boxModelAdjust: De, camelize: y, children: X, clamp: rt, createEvent: Oe, css: u, data: mt, dimensions: S, each: Ee, empty: _o, endsWith: E, escape: js, fastdom: Jt, filter: ai, find: Ls, findAll: ci, findIndex: H, flipPosition: Zi, fragment: Rt, getCoveringElement: nn, getEventPos: jt, getIndex: kt, getTargetedElement: Wi, hasAttr: Lt, hasClass: T, hasOwn: f, hasTouch: Ce, height: $t, html: Dt, hyphenate: b, inBrowser: ce, includes: x, index: Ft, intersectRect: Fi, isArray: j, isBoolean: Ae, isDocument: Qe, isElement: _e, isEmpty: zi, isEqual: ii, isFocusable: ri, isFunction: gt, isInView: mi, isInput: Ui, isNode: ti, isNumber: ei, isNumeric: Mt, isObject: Ut, isPlainObject: Ze, isRtl: at, isSameSiteAnchor: Me, isString: tt, isTag: Q, isTouch: It, isUndefined: dt, isVisible: et, isVoidElement: zs, isWindow: Hi, last: re, matches: R, memoize: Et, mute: Bo, noop: U, observeIntersection: Oo, observeMutation: Zs, observeResize: gi, observeViewportResize: Ks, off: he, offset: L, offsetPosition: fi, offsetViewport: xt, on: P, once: K, overflowParents: fe, parent: W, parents: Te, pause: No, pick: Li, play: Qs, pointInRect: ji, pointerCancel: qi, pointerDown: Ct, pointerEnter: Vt, pointerLeave: Gt, pointerMove: ni, pointerUp: Wt, position: Ys, positionAt: Ro, prepend: El, propName: Vi, query: ft, queryAll: li, ready: Al, remove: vt, removeAttr: si, removeClass: q, replaceClass: Ri, resetProps: Ot, scrollIntoView: Fo, scrollParent: Kt, scrollParents: de, scrolledOver: is, selFocusable: Ie, selInput: oi, sortBy: po, startsWith: J, sumBy: ae, swap: Ns, toArray: pt, toBoolean: Ds, toEventTargets: qs, toFloat: N, toNode: ot, toNodes: z, toNumber: zt, toPx: ht, toWindow: oe, toggleClass: Z, trigger: _, ucfirst: F, uniqueBy: go, unwrap: di, width: Ki, wrapAll: ui, wrapInner: Gs }), wt = { connected() { B(this.$el, this.$options.id) } }; const Yl = ["days", "hours", "minutes", "seconds"]; var Xl = { mixins: [wt], props: { date: String, clsWrapper: String, role: String, reload: Boolean }, data: { date: "", clsWrapper: ".uk-countdown-%unit%", role: "timer", reload: !1 }, connected() { this.$el.role = this.role, this.date = N(Date.parse(this.$props.date)), this.started = this.end = !1, this.start() }, disconnected() { this.stop() }, events: { name: "visibilitychange", el: () => document, handler() { document.hidden ? this.stop() : this.start() } }, methods: { start() { this.stop(), this.update() }, stop() { this.timer && (clearInterval(this.timer), _(this.$el, "countdownstop"), this.timer = null) }, update() { const t = Jl(this.date); t.total ? this.timer || (this.started = !0, this.timer = setInterval(this.update, 1e3), _(this.$el, "countdownstart")) : (this.stop(), this.end || (_(this.$el, "countdownend"), this.end = !0, this.reload && this.started && window.location.reload())); for (const e of Yl) { const i = I(this.clsWrapper.replace("%unit%", e), this.$el); if (!i) continue; let s = Math.trunc(t[e]).toString().padStart(2, "0"); i.textContent !== s && (s = s.split(""), s.length !== i.children.length && Dt(i, s.map(() => "<span></span>").join("")), s.forEach((n, o) => i.children[o].textContent = n)) } } } }; function Jl(t) { const e = Math.max(0, t - Date.now()) / 1e3; return { total: e, seconds: e % 60, minutes: e / 60 % 60, hours: e / 60 / 60 % 24, days: e / 60 / 60 / 24 } } const lt = {}; lt.events = lt.watch = lt.observe = lt.created = lt.beforeConnect = lt.connected = lt.beforeDisconnect = lt.disconnected = lt.destroy = ln, lt.args = function (t, e) { return e !== !1 && ln(e || t) }, lt.update = function (t, e) { return po(ln(t, gt(e) ? { read: e } : e), "order") }, lt.props = function (t, e) { if (j(e)) { const i = {}; for (const s of e) i[s] = String; e = i } return lt.methods(t, e) }, lt.computed = lt.methods = function (t, e) { return e ? t ? { ...t, ...e } : e : t }, lt.i18n = lt.data = function (t, e, i) { return i ? Jo(t, e, i) : e ? t ? function (s) { return Jo(t, e, s) } : e : t }; function Jo(t, e, i) { return lt.computed(gt(t) ? t.call(i, i) : t, gt(e) ? e.call(i, i) : e) } function ln(t, e) { return t = t && !j(t) ? [t] : t, e ? t ? t.concat(e) : j(e) ? e : [e] : t } function Kl(t, e) { return dt(e) ? t : e } function vi(t, e, i) { const s = {}; if (gt(e) && (e = e.options), e.extends && (t = vi(t, e.extends, i)), e.mixins) for (const o of e.mixins) t = vi(t, o, i); for (const o in t) n(o); for (const o in e) f(t, o) || n(o); function n(o) { s[o] = (lt[o] || Kl)(t[o], e[o], i) } return s } function Be(t, e = []) { try { return t ? J(t, "{") ? JSON.parse(t) : e.length && !x(t, ":") ? { [e[0]]: t } : t.split(";").reduce((i, s) => { const [n, o] = s.split(/:(.*)/); return n && !dt(o) && (i[n.trim()] = o.trim()), i }, {}) : {} } catch { return {} } } function cn(t, e) { return t === Boolean ? Ds(e) : t === Number ? zt(e) : t === "list" ? Ql(e) : t === Object && tt(e) ? Be(e) : t ? t(e) : e } const Zl = /,(?![^(]*\))/; function Ql(t) { return j(t) ? t : tt(t) ? t.split(Zl).map(e => Mt(e) ? zt(e) : Ds(e.trim())) : [t] } function tc(t) { t._data = {}, t._updates = [...t.$options.update || []], t._disconnect.push(() => t._updates = t._data = null) } function ec(t, e) { t._updates.unshift(e) } function $i(t, e = "update") { t._connected && t._updates.length && (t._updateCount || (t._updateCount = 0, requestAnimationFrame(() => t._updateCount = 0)), t._queued || (t._queued = new Set, Jt.read(() => { t._connected && ic(t, t._queued), t._queued = null })), t._updateCount++ < 20 && t._queued.add(e.type || e)) } function ic(t, e) { for (const { read: i, write: s, events: n = [] } of t._updates) { if (!e.has("update") && !n.some(r => e.has(r))) continue; let o; i && (o = i.call(t, t._data, e), o && Ze(o) && bt(t._data, o)), s && o !== !1 && Jt.write(() => { t._connected && s.call(t, t._data, e) }) } } function _t(t) { return xi(gi, t, "resize") } function pe(t) { return xi(Oo, t) } function bi(t) { return xi(Zs, t) } function ns(t = {}) { return pe({ handler: function (e, i) { const { targets: s = this.$el, preload: n = 5 } = t; for (const o of z(gt(s) ? s(this) : s)) G('[loading="lazy"]', o).slice(0, n - 1).forEach(r => si(r, "loading")); for (const o of e.filter(({ isIntersecting: r }) => r).map(({ target: r }) => r)) i.unobserve(o) }, ...t }) } function hn(t) { return xi((e, i) => Ks(i), t, "resize") } function wi(t) { return xi((e, i) => ({ disconnect: P(nc(e), "scroll", i, { passive: !0 }) }), t, "scroll") } function Ko(t) { return { observe(e, i) { return { observe: U, unobserve: U, disconnect: P(e, Ct, i, { passive: !0 }) } }, handler(e) { if (!It(e)) return; const i = jt(e), s = "tagName" in e.target ? e.target : W(e.target); K(document, `${Wt} ${qi} scroll`, n => { const { x: o, y: r } = jt(n); (n.type !== "scroll" && s && o && Math.abs(i.x - o) > 100 || r && Math.abs(i.y - r) > 100) && setTimeout(() => { _(s, "swipe"), _(s, `swipe${sc(i.x, i.y, o, r)}`) }) }) }, ...t } } function xi(t, e, i) { return { observe: t, handler() { $i(this, i) }, ...e } } function sc(t, e, i, s) { return Math.abs(t - i) >= Math.abs(e - s) ? t - i > 0 ? "Left" : "Right" : e - s > 0 ? "Up" : "Down" } function nc(t) { return z(t).map(e => { const { ownerDocument: i } = e, s = Kt(e, !0); return s === i.scrollingElement ? i : s }) } var Zo = { props: { margin: String, firstColumn: Boolean }, data: { margin: "uk-margin-small-top", firstColumn: "uk-first-column" }, observe: [bi({ options: { childList: !0 } }), bi({ options: { attributes: !0, attributeFilter: ["style"] } }), _t({ handler(t) { for (const { borderBoxSize: [{ inlineSize: e, blockSize: i }] } of t) if (e || i) { this.$emit("resize"); return } }, target: ({ $el: t }) => [t, ...X(t)] })], update: { read() { return { rows: un(X(this.$el)) } }, write({ rows: t }) { for (const e of t) for (const i of e) Z(i, this.margin, t[0] !== e), Z(i, this.firstColumn, e[at ? e.length - 1 : 0] === i) }, events: ["resize"] } }; function un(t) { const e = [[]], i = t.some((s, n) => n && t[n - 1].offsetParent !== s.offsetParent); for (const s of t) { if (!et(s)) continue; const n = dn(s, i); for (let o = e.length - 1; o >= 0; o--) { const r = e[o]; if (!r[0]) { r.push(s); break } const a = dn(r[0], i); if (n.top >= a.bottom - 1 && n.top !== a.top) { e.push([s]); break } if (n.bottom - 1 > a.top || n.top === a.top) { let c = r.length - 1; for (; c >= 0; c--) { const g = dn(r[c], i); if (n.left >= g.left) break } r.splice(c + 1, 0, s); break } if (o === 0) { e.unshift([s]); break } } } return e } function dn(t, e = !1) { let { offsetTop: i, offsetLeft: s, offsetHeight: n, offsetWidth: o } = t; return e && ([i, s] = fi(t)), { top: i, left: s, bottom: i + n, right: s + o } } function yi() { return new Promise(t => requestAnimationFrame(t)) } function He(t) { return new Promise(e => setTimeout(e, t)) } const fn = "uk-transition-leave", pn = "uk-transition-enter"; function Qo(t, e, i, s = 0) { const n = gn(e, !0), o = { opacity: 1 }, r = { opacity: 0 }, a = () => n === gn(e), c = v => () => a() ? v() : Promise.reject(), g = c(async () => { B(e, fn), await (s ? er(e).reduce(async (v, w, A, M) => { if (await v, !mi(w) || !a()) { u(w, r); return } await He(s); const k = V.start(w, r, i / 2, "ease"); M.length - 1 === A && await k }, Promise.resolve()) : V.start(e, r, i / 2, "ease")), q(e, fn) }), m = c(async () => { const v = $t(e); B(e, pn), t(), u(s ? X(e) : e, r), $t(e, v), await He(), $t(e, ""); const w = $t(e); u(e, "alignContent", "flex-start"), $t(e, v); let A = [], M = i / 2; if (s) { const k = er(e); u(X(e), r), A = k.reduce(async (D, ut, Tt, Nt) => { if (await D, !mi(ut) || !a()) { Ot(ut, o); return } await He(s); const Pt = V.start(ut, o, i / 2, "ease").then(() => a() && Ot(ut, o)); Nt.length - 1 === Tt && await Pt }, Promise.resolve()), M += k.length * s } if (!s || v !== w) { const k = { height: w, ...s ? {} : o }; A.push(V.start(e, k, M, "ease")) } await Promise.all(A), q(e, pn), a() && (Ot(e, { height: "", alignContent: "", ...o }), delete e.dataset.transition) }); return T(e, fn) ? tr(e).then(m) : T(e, pn) ? tr(e).then(g).then(m) : g().then(m) } function gn(t, e) { return e && (t.dataset.transition = 1 + gn(t)), zt(t.dataset.transition) || 0 } function tr(t) { return Promise.all(X(t).filter(V.inProgress).map(e => new Promise(i => K(e, "transitionend transitioncanceled", i)))) } function er(t) { return un(X(t)).flat().filter(et) } async function oc(t, e, i) { await yi(); let s = X(e); const n = s.map(k => ir(k, !0)), o = { ...u(e, ["height", "padding"]), display: "block" }, r = s.filter(k => mi(k)), a = s.concat(e); await Promise.all(a.map(V.cancel)), u(a, "transitionProperty", "none"), await t(); const c = X(e).filter(k => !x(s, k)); s = s.concat(c), await Promise.resolve(), u(a, "transitionProperty", ""); const g = O(e, "style"), m = u(e, ["height", "padding"]), [v, w] = rc(e, s, n), A = s.map(k => ({ style: O(k, "style") })); r.push(...s.filter(k => mi(k))), s.forEach((k, D) => w[D] && u(k, w[D])), u(e, o), _(e, "scroll"), await yi(); const M = s.map((k, D) => { if (W(k) === e && r.includes(k)) return V.start(k, v[D], i, "ease", !c.includes(k)) }).concat(V.start(e, m, i, "ease", !0)); try { await Promise.all(M), s.forEach((k, D) => { O(k, A[D]), W(k) === e && u(k, "display", v[D].opacity === 0 ? "none" : "") }), O(e, "style", g) } catch { O(s, "style", ""), Ot(e, o) } } function ir(t, e) { const i = u(t, "zIndex"); return et(t) ? { display: "", opacity: e ? u(t, "opacity") : "0", pointerEvents: "none", position: "absolute", zIndex: i === "auto" ? Ft(t) : i, ...sr(t) } : !1 } function rc(t, e, i) { const s = e.map((o, r) => W(o) && r in i ? i[r] ? et(o) ? sr(o) : { opacity: 0 } : { opacity: et(o) ? 1 : 0 } : !1), n = s.map((o, r) => { const a = W(e[r]) === t && (i[r] || ir(e[r])); if (!a) return !1; if (!o) delete a.opacity; else if (!("opacity" in o)) { const { opacity: c } = a; c % 1 ? o.opacity = 1 : delete a.opacity } return a }); return [s, n] } function sr(t) { const { height: e, width: i } = S(t); let { top: s, left: n } = Ys(t); const o = xt(t.ownerDocument); return s = rt(s, o.top - e - o.height, o.bottom + o.height), n = rt(n, o.left - i - o.width, o.right + o.width), { height: e, width: i, top: s, left: n, transform: "", ...u(t, ["marginTop", "marginLeft"]) } } var nr = { props: { duration: Number, animation: Boolean }, data: { duration: 150, animation: "slide" }, methods: { animate(t, e = this.$el) { const i = this.animation; return (i === "fade" ? Qo : i === "delayed-fade" ? (...n) => Qo(...n, 40) : i ? oc : () => (t(), Promise.resolve()))(t, e, this.duration).catch(U) } } }; function qt(t) { t.target.closest('a[href="#"],a[href=""]') && t.preventDefault() } const Y = { TAB: 9, ESC: 27, SPACE: 32, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40 }; var ac = { mixins: [nr], args: "target", props: { target: String, selActive: Boolean }, data: { target: "", selActive: !1, attrItem: "uk-filter-control", cls: "uk-active", duration: 250 }, computed: { children: ({ target: t }, e) => G(`${t} > *`, e), toggles: ({ attrItem: t }, e) => G(`[${t}],[data-${t}]`, e) }, watch: { toggles(t) { this.updateState(); const e = G(this.selActive, this.$el); for (const i of t) { this.selActive !== !1 && Z(i, this.cls, x(e, i)); const s = dc(i); Q(s, "a") && (s.role = "button") } }, children(t, e) { e && this.updateState() } }, events: { name: "click keydown", delegate: ({ attrItem: t }) => `[${t}],[data-${t}]`, handler(t) { t.type === "keydown" && t.keyCode !== Y.SPACE || t.target.closest("a,button") && (qt(t), this.apply(t.current)) } }, methods: { apply(t) { const e = this.getState(), i = rr(t, this.attrItem, this.getState()); lc(e, i) || this.setState(i) }, getState() { return this.toggles.filter(t => T(t, this.cls)).reduce((t, e) => rr(e, this.attrItem, t), { filter: { "": "" }, sort: [] }) }, async setState(t, e = !0) { t = { filter: { "": "" }, sort: [], ...t }, _(this.$el, "beforeFilter", [this, t]); for (const i of this.toggles) Z(i, this.cls, hc(i, this.attrItem, t)); await Promise.all(G(this.target, this.$el).map(i => { const s = () => cc(t, i, X(i)); return e ? this.animate(s, i) : s() })), _(this.$el, "afterFilter", [this]) }, updateState() { Jt.write(() => this.setState(this.getState(), !1)) } } }; function or(t, e) { return Be(mt(t, e), ["filter"]) } function lc(t, e) { return ["filter", "sort"].every(i => ii(t[i], e[i])) } function cc(t, e, i) { for (const o of i) u(o, "display", Object.values(t.filter).every(r => !r || R(o, r)) ? "" : "none"); const [s, n] = t.sort; if (s) { const o = uc(i, s, n); ii(o, i) || it(e, o) } } function rr(t, e, i) { const { filter: s, group: n, sort: o, order: r = "asc" } = or(t, e); return (s || dt(o)) && (n ? s ? (delete i.filter[""], i.filter[n] = s) : (delete i.filter[n], (zi(i.filter) || "" in i.filter) && (i.filter = { "": s || "" })) : i.filter = { "": s || "" }), dt(o) || (i.sort = [o, r]), i } function hc(t, e, { filter: i = { "": "" }, sort: [s, n] }) { const { filter: o = "", group: r = "", sort: a, order: c = "asc" } = or(t, e); return dt(a) ? r in i && o === i[r] || !o && r && !(r in i) && !i[""] : s === a && n === c } function uc(t, e, i) { return [...t].sort((s, n) => mt(s, e).localeCompare(mt(n, e), void 0, { numeric: !0 }) * (i === "asc" || -1)) } function dc(t) { return I("a,button", t) || t } var fc = { args: "dataSrc", props: { dataSrc: String, sources: String, margin: String, target: String, loading: String }, data: { dataSrc: "", sources: !1, margin: "50%", target: !1, loading: "lazy" }, connected() { this.loading !== "lazy" ? this.load() : vn(this.$el) && (this.$el.loading = "lazy", mn(this.$el)) }, disconnected() { this.img && (this.img.onload = ""), delete this.img }, observe: pe({ handler(t, e) { this.load(), e.disconnect() }, options: ({ margin: t }) => ({ rootMargin: t }), filter: ({ loading: t }) => t === "lazy", target: ({ $el: t, $props: e }) => e.target ? [t, ...li(e.target, t)] : t }), methods: { load() { if (this.img) return this.img; const t = vn(this.$el) ? this.$el : gc(this.$el, this.dataSrc, this.sources); return si(t, "loading"), mn(this.$el, t.currentSrc), this.img = t } } }; function mn(t, e) { if (vn(t)) { const i = W(t); (Q(i, "picture") ? X(i) : [t]).forEach(n => ar(n, n)) } else e && !x(t.style.backgroundImage, e) && (u(t, "backgroundImage", `url(${js(e)})`), _(t, Oe("load", !1))) } const pc = ["data-src", "data-srcset", "sizes"]; function ar(t, e) { for (const i of pc) { const s = mt(t, i); s && O(e, i.replace(/data-/g, ""), s) } } function gc(t, e, i) { const s = new Image; return lr(s, i), ar(t, s), s.onload = () => mn(t, s.currentSrc), s.src = e, s } function lr(t, e) { if (e = mc(e), e.length) { const i = Rt("<picture>"); for (const s of e) { const n = Rt("<source>"); O(n, s), it(i, n) } it(i, t) } } function mc(t) { if (!t) return []; if (J(t, "[")) try { t = JSON.parse(t) } catch { t = [] } else t = Be(t); return j(t) || (t = [t]), t.filter(e => !zi(e)) } function vn(t) { return Q(t, "img") } let $n; function cr(t) { const e = P(t, "touchstart", n => { if (n.targetTouches.length !== 1 || R(n.target, 'input[type="range"')) return; let o = jt(n).y; const r = P(t, "touchmove", a => { const c = jt(a).y; c !== o && (o = c, de(a.target).some(g => { if (!t.contains(g)) return !1; let { scrollHeight: m, clientHeight: v } = g; return v < m }) || a.preventDefault()) }, { passive: !1 }); K(t, "scroll touchend touchcanel", r, { capture: !0 }) }, { passive: !0 }); if ($n) return e; $n = !0; const { scrollingElement: i } = document, s = { overflowY: CSS.supports("overflow", "clip") ? "clip" : "hidden", touchAction: "none", scrollbarGutter: Ki(window) - i.clientWidth ? "stable" : "" }; return u(i, s), () => { $n = !1, e(), Ot(i, s) } } var ki = { props: { container: Boolean }, data: { container: !0 }, computed: { container({ container: t }) { return t === !0 && this.$container || t && I(t) } } }, hr = { props: { pos: String, offset: Boolean, flip: Boolean, shift: Boolean, inset: Boolean }, data: { pos: `bottom-${at ? "right" : "left"}`, offset: !1, flip: !0, shift: !0, inset: !1 }, connected() { this.pos = this.$props.pos.split("-").concat("center").slice(0, 2), [this.dir, this.align] = this.pos, this.axis = x(["top", "bottom"], this.dir) ? "y" : "x" }, methods: { positionAt(t, e, i) { let s = [this.getPositionOffset(t), this.getShiftOffset(t)]; const n = [this.flip && "flip", this.shift && "shift"], o = { element: [this.inset ? this.dir : Zi(this.dir), this.align], target: [this.dir, this.align] }; if (this.axis === "y") { for (const c in o) o[c].reverse(); s.reverse(), n.reverse() } const r = os(t), a = S(t); u(t, { top: -a.height, left: -a.width }), Ro(t, e, { attach: o, offset: s, boundary: i, placement: n, viewportOffset: this.getViewportOffset(t) }), r() }, getPositionOffset(t = this.$el) { return ht(this.offset === !1 ? u(t, "--uk-position-offset") : this.offset, this.axis === "x" ? "width" : "height", t) * (x(["left", "top"], this.dir) ? -1 : 1) * (this.inset ? -1 : 1) }, getShiftOffset(t = this.$el) { return this.align === "center" ? 0 : ht(u(t, "--uk-position-shift-offset"), this.axis === "y" ? "width" : "height", t) * (x(["left", "top"], this.align) ? 1 : -1) }, getViewportOffset(t) { return ht(u(t, "--uk-position-viewport-offset")) } } }; function os(t) { const e = Kt(t), { scrollTop: i } = e, s = () => { i !== e.scrollTop && (e.scrollTop = i) }; return () => { s(), setTimeout(s) } } var ge = { props: { cls: Boolean, animation: "list", duration: Number, velocity: Number, origin: String, transition: String }, data: { cls: !1, animation: [!1], duration: 200, velocity: .2, origin: !1, transition: "ease", clsEnter: "uk-togglable-enter", clsLeave: "uk-togglable-leave" }, computed: { hasAnimation: ({ animation: t }) => !!t[0], hasTransition: ({ animation: t }) => ["slide", "reveal"].some(e => J(t[0], e)) }, methods: { async toggleElement(t, e, i) { try { return await Promise.all(z(t).map(s => { const n = Ae(e) ? e : !this.isToggled(s); if (!_(s, `before${n ? "show" : "hide"}`, [this])) return Promise.reject(); const o = (gt(i) ? i : i === !1 || !this.hasAnimation ? vc : this.hasTransition ? $c : bc)(s, n, this), r = n ? this.clsEnter : this.clsLeave; B(s, r), _(s, n ? "show" : "hide", [this]); const a = () => { var c; if (q(s, r), _(s, n ? "shown" : "hidden", [this]), n) { const g = os(s); (c = G("[autofocus]", s).find(et)) == null || c.focus(), g() } }; return o ? o.then(a, () => (q(s, r), Promise.reject())) : a() })), !0 } catch { return !1 } }, isToggled(t = this.$el) { return t = ot(t), T(t, this.clsEnter) ? !0 : T(t, this.clsLeave) ? !1 : this.cls ? T(t, this.cls.split(" ")[0]) : et(t) }, _toggle(t, e) { if (!t) return; e = !!e; let i; this.cls ? (i = x(this.cls, " ") || e !== T(t, this.cls), i && Z(t, this.cls, x(this.cls, " ") ? void 0 : e)) : (i = e === t.hidden, i && (t.hidden = !e)), i && _(t, "toggled", [e, this]) } } }; function vc(t, e, { _toggle: i }) { return Yt.cancel(t), V.cancel(t), i(t, e) } async function $c(t, e, { animation: i, duration: s, velocity: n, transition: o, _toggle: r }) { var a; const [c = "reveal", g = "top"] = ((a = i[0]) == null ? void 0 : a.split("-")) || [], m = [["left", "right"], ["top", "bottom"]], v = m[x(m[0], g) ? 0 : 1], w = v[1] === g, M = ["width", "height"][m.indexOf(v)], k = `margin-${v[0]}`, D = `margin-${g}`; let ut = S(t)[M]; const Tt = V.inProgress(t); await V.cancel(t), e && r(t, !0); const Nt = Object.fromEntries(["padding", "border", "width", "height", "minWidth", "minHeight", "overflowY", "overflowX", k, D].map(Ea => [Ea, t.style[Ea]])), Pt = S(t), Bn = N(u(t, k)), Sa = N(u(t, D)), ye = Pt[M] + Sa; !Tt && !e && (ut += Sa); const [ws] = Gs(t, "<div>"); u(ws, { boxSizing: "border-box", height: Pt.height, width: Pt.width, ...u(t, ["overflow", "padding", "borderTop", "borderRight", "borderBottom", "borderLeft", "borderImage", D]) }), u(t, { padding: 0, border: 0, minWidth: 0, minHeight: 0, [D]: 0, width: Pt.width, height: Pt.height, overflow: "hidden", [M]: ut }); const _a = ut / ye; s = (n * ye + s) * (e ? 1 - _a : _a); const Aa = { [M]: e ? ye : 0 }; w && (u(t, k, ye - ut + Bn), Aa[k] = e ? Bn : ye + Bn), !w ^ c === "reveal" && (u(ws, k, -ye + ut), V.start(ws, { [k]: e ? 0 : -ye }, s, o)); try { await V.start(t, Aa, s, o) } finally { u(t, Nt), di(ws.firstChild), e || r(t, !1) } } function bc(t, e, i) { const { animation: s, duration: n, _toggle: o } = i; return e ? (o(t, !0), Yt.in(t, s[0], n, i.origin)) : Yt.out(t, s[1] || s[0], n, i.origin).then(() => o(t, !1)) } const yt = []; var bn = { mixins: [wt, ki, ge], props: { selPanel: String, selClose: String, escClose: Boolean, bgClose: Boolean, stack: Boolean, role: String }, data: { cls: "uk-open", escClose: !0, bgClose: !0, overlay: !0, stack: !1, role: "dialog" }, computed: { panel: ({ selPanel: t }, e) => I(t, e), transitionElement() { return this.panel } }, connected() { const t = this.panel || this.$el; t.role = this.role, this.overlay && (t.ariaModal = !0) }, beforeDisconnect() { x(yt, this) && this.toggleElement(this.$el, !1, !1) }, events: [{ name: "click", delegate: ({ selClose: t }) => `${t},a[href*="#"]`, handler(t) { const { current: e, defaultPrevented: i } = t, { hash: s } = e; !i && s && Me(e) && !this.$el.contains(I(s)) ? this.hide() : R(e, this.selClose) && (qt(t), this.hide()) } }, { name: "toggle", self: !0, handler(t, e) { t.defaultPrevented || (t.preventDefault(), this.target = e?.$el, this.isToggled() === x(yt, this) && this.toggle()) } }, { name: "beforeshow", self: !0, handler(t) { if (x(yt, this)) return !1; !this.stack && yt.length ? (Promise.all(yt.map(e => e.hide())).then(this.show), t.preventDefault()) : yt.push(this) } }, { name: "show", self: !0, handler() { this.stack && u(this.$el, "zIndex", N(u(this.$el, "zIndex")) + yt.length); const t = [this.overlay && xc(this), this.overlay && cr(this.$el), this.bgClose && yc(this), this.escClose && kc(this)]; K(this.$el, "hidden", () => t.forEach(e => e && e()), { self: !0 }), B(document.documentElement, this.clsPage), dr(this.target, !0) } }, { name: "shown", self: !0, handler() { ri(this.$el) || (this.$el.tabIndex = -1), R(this.$el, ":focus-within") || this.$el.focus() } }, { name: "hidden", self: !0, handler() { x(yt, this) && yt.splice(yt.indexOf(this), 1), u(this.$el, "zIndex", ""); const { target: t } = this; yt.some(e => e.clsPage === this.clsPage) || (q(document.documentElement, this.clsPage), queueMicrotask(() => { if (ri(t)) { const e = os(t); t.focus(), e() } })), dr(t, !1), this.target = null } }], methods: { toggle() { return this.isToggled() ? this.hide() : this.show() }, async show() { return this.container && W(this.$el) !== this.container && (it(this.container, this.$el), await yi()), this.toggleElement(this.$el, !0, ur) }, hide() { return this.toggleElement(this.$el, !1, ur) } } }; function ur(t, e, { transitionElement: i, _toggle: s }) { return new Promise((n, o) => K(t, "show hide", () => { var r; (r = t._reject) == null || r.call(t), t._reject = o, s(t, e); const a = K(i, "transitionstart", () => { K(i, "transitionend transitioncancel", n, { self: !0 }), clearTimeout(c) }, { self: !0 }), c = setTimeout(() => { a(), n() }, wc(u(i, "transitionDuration"))) })).then(() => delete t._reject) } function wc(t) { return t ? E(t, "ms") ? N(t) : N(t) * 1e3 : 0 } function xc(t) { return P(document, "focusin", e => { re(yt) === t && !t.$el.contains(e.target) && t.$el.focus() }) } function yc(t) { return P(document, Ct, ({ target: e }) => { re(yt) !== t || t.overlay && !t.$el.contains(e) || !t.panel || t.panel.contains(e) || K(document, `${Wt} ${qi} scroll`, ({ defaultPrevented: i, type: s, target: n }) => { !i && s === Wt && e === n && t.hide() }, !0) }) } function kc(t) { return P(document, "keydown", e => { e.keyCode === 27 && re(yt) === t && t.hide() }) } function dr(t, e) { t?.ariaExpanded && (t.ariaExpanded = e) } var wn = { slide: { show(t) { return [{ transform: st(t * -100) }, { transform: st() }] }, percent(t) { return Si(t) }, translate(t, e) { return [{ transform: st(e * -100 * t) }, { transform: st(e * 100 * (1 - t)) }] } } }; function Si(t) { return Math.abs(new DOMMatrix(u(t, "transform")).m41 / t.offsetWidth) } function st(t = 0, e = "%") { return t ? `translate3d(${t + e}, 0, 0)` : "" } function Sc(t, e, i, { animation: s, easing: n }) { const { percent: o, translate: r, show: a = U } = s, c = a(i), { promise: g, resolve: m } = fr(); return { dir: i, show(v, w = 0, A) { const M = A ? "linear" : n; return v -= Math.round(v * rt(w, -1, 1)), this.translate(w), me(e, "itemin", { percent: w, duration: v, timing: M, dir: i }), me(t, "itemout", { percent: 1 - w, duration: v, timing: M, dir: i }), Promise.all([V.start(e, c[1], v, M), V.start(t, c[0], v, M)]).then(() => { this.reset(), m() }, U), g }, cancel() { return V.cancel([e, t]) }, reset() { Ot([e, t], c[0]) }, async forward(v, w = this.percent()) { return await this.cancel(), this.show(v, w, !0) }, translate(v) { this.reset(); const w = r(v, i); u(e, w[1]), u(t, w[0]), me(e, "itemtranslatein", { percent: v, dir: i }), me(t, "itemtranslateout", { percent: 1 - v, dir: i }) }, percent() { return o(t || e, e, i) }, getDistance() { return t?.offsetWidth } } } function me(t, e, i) { _(t, Oe(e, !1, !1, i)) } function fr() { let t; return { promise: new Promise(e => t = e), resolve: t } } var rs = { props: { i18n: Object }, data: { i18n: null }, methods: { t(t, ...e) { var i, s, n; let o = 0; return ((n = ((i = this.i18n) == null ? void 0 : i[t]) || ((s = this.$options.i18n) == null ? void 0 : s[t])) == null ? void 0 : n.replace(/%s/g, () => e[o++] || "")) || "" } } }, _c = { props: { autoplay: Boolean, autoplayInterval: Number, pauseOnHover: Boolean }, data: { autoplay: !1, autoplayInterval: 7e3, pauseOnHover: !0 }, connected() { O(this.list, "aria-live", this.autoplay ? "off" : "polite"), this.autoplay && this.startAutoplay() }, disconnected() { this.stopAutoplay() }, update() { O(this.slides, "tabindex", "-1") }, events: [{ name: "visibilitychange", el: () => document, filter: ({ autoplay: t }) => t, handler() { document.hidden ? this.stopAutoplay() : this.startAutoplay() } }], methods: { startAutoplay() { this.stopAutoplay(), this.interval = setInterval(() => { this.stack.length || !et(this.$el) || this.draggable && R(this.$el, ":focus-within") && !R(this.$el, ":focus") || this.pauseOnHover && R(this.$el, ":hover") || this.show("next") }, this.autoplayInterval) }, stopAutoplay() { clearInterval(this.interval) } } }; const as = { passive: !1, capture: !0 }, pr = { passive: !0, capture: !0 }, Ac = "touchstart mousedown", xn = "touchmove mousemove", gr = "touchend touchcancel mouseup click input scroll"; var Ec = { props: { draggable: Boolean }, data: { draggable: !0, threshold: 10 }, created() { for (const t of ["start", "move", "end"]) { const e = this[t]; this[t] = i => { const s = jt(i).x * (at ? -1 : 1); this.prevPos = s === this.pos ? this.prevPos : this.pos, this.pos = s, e(i) } } }, events: [{ name: Ac, passive: !0, delegate: ({ selList: t }) => `${t} > *`, handler(t) { !this.draggable || this.parallax || !It(t) && Cc(t.target) || t.target.closest(oi) || t.button > 0 || this.length < 2 || this.start(t) } }, { name: "dragstart", handler(t) { t.preventDefault() } }, { name: xn, el: ({ list: t }) => t, handler: U, ...as }], methods: { start() { this.drag = this.pos, this._transitioner ? (this.percent = this._transitioner.percent(), this.drag += this._transitioner.getDistance() * this.percent * this.dir, this._transitioner.cancel(), this._transitioner.translate(this.percent), this.dragging = !0, this.stack = []) : this.prevIndex = this.index, P(document, xn, this.move, as), P(document, gr, this.end, pr), u(this.list, "userSelect", "none") }, move(t) { const e = this.pos - this.drag; if (e === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(e) < this.threshold) return; t.cancelable && t.preventDefault(), this.dragging = !0, this.dir = e < 0 ? 1 : -1; let { slides: i, prevIndex: s } = this, n = Math.abs(e), o = this.getIndex(s + this.dir), r = mr.call(this, s, o); for (; o !== s && n > r;)this.drag -= r * this.dir, s = o, n -= r, o = this.getIndex(s + this.dir), r = mr.call(this, s, o); this.percent = n / r; const a = i[s], c = i[o], g = this.index !== o, m = s === o; let v; for (const w of [this.index, this.prevIndex]) x([o, s], w) || (_(i[w], "itemhidden", [this]), m && (v = !0, this.prevIndex = s)); (this.index === s && this.prevIndex !== s || v) && _(i[this.index], "itemshown", [this]), g && (this.prevIndex = s, this.index = o, m || (_(a, "beforeitemhide", [this]), _(a, "itemhide", [this])), _(c, "beforeitemshow", [this]), _(c, "itemshow", [this])), this._transitioner = this._translate(Math.abs(this.percent), a, !m && c) }, end() { if (he(document, xn, this.move, as), he(document, gr, this.end, pr), this.dragging) if (setTimeout(P(this.list, "click", t => t.preventDefault(), as)), this.dragging = null, this.index === this.prevIndex) this.percent = 1 - this.percent, this.dir *= -1, this._show(!1, this.index, !0), this._transitioner = null; else { const t = (at ? this.dir * (at ? 1 : -1) : this.dir) < 0 == this.prevPos > this.pos; this.index = t ? this.index : this.prevIndex, t && (_(this.slides[this.prevIndex], "itemhidden", [this]), _(this.slides[this.index], "itemshown", [this]), this.percent = 1 - this.percent), this.show(this.dir > 0 && !t || this.dir < 0 && t ? "next" : "previous", !0) } u(this.list, { userSelect: "" }), this.drag = this.percent = null } } }; function mr(t, e) { return this._getTransitioner(t, t !== e && e).getDistance() || this.slides[t].offsetWidth } function Cc(t) { return u(t, "userSelect") !== "none" && pt(t.childNodes).some(e => e.nodeType === 3 && e.textContent.trim()) } function Pc(t) { t._watches = []; for (const e of t.$options.watch || []) for (const [i, s] of Object.entries(e)) vr(t, s, i); t._initial = !0 } function vr(t, e, i) { t._watches.push({ name: i, ...Ze(e) ? e : { handler: e } }) } function Ic(t, e) { for (const { name: i, handler: s, immediate: n = !0 } of t._watches) (t._initial && n || f(e, i) && !ii(e[i], t[i])) && s.call(t, t[i], e[i]); t._initial = !1 } function Tc(t) { const { computed: e } = t.$options; if (t._computed = {}, e) for (const i in e) br(t, i, e[i]) } const $r = { subtree: !0, childList: !0 }; function br(t, e, i) { t._hasComputed = !0, Object.defineProperty(t, e, { enumerable: !0, get() { const { _computed: s, $props: n, $el: o } = t; if (!f(s, e) && (s[e] = (i.get || i).call(t, n, o), i.observe && t._computedObserver)) { const r = i.observe.call(t, n); t._computedObserver.observe(["~", "+", "-"].includes(r[0]) ? o.parentElement : o.getRootNode(), $r) } return s[e] }, set(s) { const { _computed: n } = t; n[e] = i.set ? i.set.call(t, s) : s, dt(n[e]) && delete n[e] } }) } function Mc(t) { t._hasComputed && (ec(t, { read: () => Ic(t, wr(t)), events: ["resize", "computed"] }), t._computedObserver = Zs(t.$el, () => $i(t, "computed"), $r), t._disconnect.push(() => { t._computedObserver.disconnect(), t._computedObserver = null, wr(t) })) } function wr(t) { const e = { ...t._computed }; return t._computed = {}, e } function Oc(t) { for (const e of t.$options.events || []) if (f(e, "handler")) xr(t, e); else for (const i in e) xr(t, { name: i, handler: e[i] }) } function xr(t, { name: e, el: i, handler: s, capture: n, passive: o, delegate: r, filter: a, self: c }) { a && !a.call(t, t) || t._disconnect.push(P(i ? i.call(t, t) : t.$el, e, r?.call(t, t), s.bind(t), { passive: o, capture: n, self: c })) } function Dc(t) { for (const e of t.$options.observe || []) Nc(t, e) } function Nc(t, e) { let { observe: i, target: s = t.$el, handler: n, options: o, filter: r, args: a } = e; if (r && !r.call(t, t)) return; const c = `_observe${t._disconnect.length}`; gt(s) && !f(t, c) && br(t, c, () => { const v = s.call(t, t); return j(v) ? z(v) : v }), n = tt(n) ? t[n] : n.bind(t), gt(o) && (o = o.call(t, t)); const g = f(t, c) ? t[c] : s, m = i(g, n, o, a); gt(s) && j(t[c]) && vr(t, { handler: Bc(m, o), immediate: !1 }, c), t._disconnect.push(() => m.disconnect()) } function Bc(t, e) { return (i, s) => { for (const n of s) x(i, n) || (t.unobserve ? t.unobserve(n) : t.observe && t.disconnect()); for (const n of i) (!x(s, n) || !t.unobserve) && t.observe(n, e) } } function Hc(t) { const { $options: e, $props: i } = t, s = yr(e); bt(i, s); const { computed: n, methods: o } = e; for (let r in i) r in s && (!n || !f(n, r)) && (!o || !f(o, r)) && (t[r] = i[r]) } function yr(t) { const e = {}, { args: i = [], props: s = {}, el: n, id: o } = t; if (!s) return e; for (const a in s) { const c = b(a); let g = mt(n, c); dt(g) || (g = s[a] === Boolean && g === "" ? !0 : cn(s[a], g), !(c === "target" && J(g, "_")) && (e[a] = g)) } const r = Be(mt(n, o), i); for (const a in r) { const c = y(a); dt(s[c]) || (e[c] = cn(s[c], r[a])) } return e } const zc = Et((t, e) => { const i = Object.keys(e), s = i.concat(t).map(n => [b(n), `data-${b(n)}`]).flat(); return { attributes: i, filter: s } }); function Lc(t) { const { $options: e, $props: i } = t, { id: s, props: n, el: o } = e; if (!n) return; const { attributes: r, filter: a } = zc(s, n), c = new MutationObserver(g => { const m = yr(e); g.some(({ attributeName: v }) => { const w = v.replace("data-", ""); return (w === s ? r : [y(w), y(v)]).some(A => !dt(m[A]) && m[A] !== i[A]) }) && t.$reset() }); c.observe(o, { attributes: !0, attributeFilter: a }), t._disconnect.push(() => c.disconnect()) } function ze(t, e) { var i; (i = t.$options[e]) == null || i.forEach(s => s.call(t)) } function yn(t) { t._connected || (Hc(t), ze(t, "beforeConnect"), t._connected = !0, t._disconnect = [], Oc(t), tc(t), Pc(t), Dc(t), Lc(t), Mc(t), ze(t, "connected"), $i(t)) } function kn(t) { t._connected && (ze(t, "beforeDisconnect"), t._disconnect.forEach(e => e()), t._disconnect = null, ze(t, "disconnected"), t._connected = !1) } let Fc = 0; function kr(t, e = {}) { e.data = qc(e, t.constructor.options), t.$options = vi(t.constructor.options, e, t), t.$props = {}, t._uid = Fc++, jc(t), Rc(t), Tc(t), ze(t, "created"), e.el && t.$mount(e.el) } function jc(t) { const { data: e = {} } = t.$options; for (const i in e) t.$props[i] = t[i] = e[i] } function Rc(t) { const { methods: e } = t.$options; if (e) for (const i in e) t[i] = e[i].bind(t) } function qc({ data: t = {} }, { args: e = [], props: i = {} }) { j(t) && (t = t.slice(0, e.length).reduce((s, n, o) => (Ze(n) ? bt(s, n) : s[e[o]] = n, s), {})); for (const s in t) dt(t[s]) ? delete t[s] : i[s] && (t[s] = cn(i[s], t[s])); return t } const At = function (t) { kr(this, t) }; At.util = Gl, At.options = {}, At.version = "3.24.2"; const Uc = "uk-", ve = "__uikit__", Le = {}; function Sr(t, e) { var i, s; const n = Uc + b(t); if (!e) return Le[n].options || (Le[n] = At.extend(Le[n])), Le[n]; t = y(t), At[t] = (r, a) => _i(t, r, a); const o = (i = e.options) != null ? i : { ...e }; return o.id = n, o.name = t, (s = o.install) == null || s.call(o, At, o, t), At._initialized && !o.functional && requestAnimationFrame(() => _i(t, `[${n}],[data-${n}]`)), Le[n] = o } function _i(t, e, i, ...s) { const n = Sr(t); return n.options.functional ? new n({ data: Ze(e) ? e : [e, i, ...s] }) : e ? G(e).map(o)[0] : o(); function o(r) { const a = ls(r, t); if (a) if (i) a.$destroy(); else return a; return new n({ el: r, data: i }) } } function Ai(t) { return t?.[ve] || {} } function ls(t, e) { return Ai(t)[e] } function Wc(t, e) { t[ve] || (t[ve] = {}), t[ve][e.$options.name] = e } function Vc(t, e) { var i; (i = t[ve]) == null || delete i[e.$options.name], zi(t[ve]) && delete t[ve] } function Gc(t) { t.component = Sr, t.getComponents = Ai, t.getComponent = ls, t.update = _r, t.use = function (i) { if (!i.installed) return i.call(null, this), i.installed = !0, this }, t.mixin = function (i, s) { s = (tt(s) ? this.component(s) : s) || this, s.options = vi(s.options, i) }, t.extend = function (i) { i || (i = {}); const s = this, n = function (r) { kr(this, r) }; return n.prototype = Object.create(s.prototype), n.prototype.constructor = n, n.options = vi(s.options, i), n.super = s, n.extend = s.extend, n }; let e; Object.defineProperty(t, "container", { get() { return e || document.body }, set(i) { e = I(i) } }) } function _r(t, e) { t = t ? ot(t) : document.body; for (const i of Te(t).reverse()) Ar(i, e); Xt(t, i => Ar(i, e)) } function Ar(t, e) { const i = Ai(t); for (const s in i) $i(i[s], e) } function Yc(t) { t.prototype.$mount = function (e) { const i = this; Wc(e, i), i.$options.el = e, e.isConnected && yn(i) }, t.prototype.$destroy = function (e = !1) { const i = this, { el: s } = i.$options; s && kn(i), ze(i, "destroy"), Vc(s, i), e && vt(i.$el) }, t.prototype.$create = _i, t.prototype.$emit = function (e) { $i(this, e) }, t.prototype.$update = function (e = this.$el, i) { _r(e, i) }, t.prototype.$reset = function () { kn(this), yn(this) }, t.prototype.$getComponent = ls, Object.defineProperties(t.prototype, { $el: { get() { return this.$options.el } }, $container: Object.getOwnPropertyDescriptor(t, "container") }) } let Xc = 1; function $e(t, e = null) { return e?.id || `${t.$options.id}-${Xc++}` } var Jc = { i18n: { next: "Next slide", previous: "Previous slide", slideX: "Slide %s", slideLabel: "%s of %s", role: "String" }, data: { selNav: !1, role: "region" }, computed: { nav: ({ selNav: t }, e) => I(t, e), navChildren() { return X(this.nav) }, selNavItem: ({ attrItem: t }) => `[${t}],[data-${t}]`, navItems(t, e) { return G(this.selNavItem, e) } }, watch: { nav(t, e) { O(t, "role", "tablist"), this.padNavitems(), e && this.$emit() }, list(t) { Q(t, "ul") && O(t, "role", "presentation") }, navChildren(t) { O(t, "role", "presentation"), this.padNavitems(), this.updateNav() }, navItems(t) { for (const e of t) { const i = mt(e, this.attrItem), s = I("a,button", e) || e; let n, o = null; if (Mt(i)) { const r = zt(i), a = this.slides[r]; a && (a.id || (a.id = $e(this, a)), o = a.id), n = this.t("slideX", N(i) + 1), s.role = "tab" } else this.list && (this.list.id || (this.list.id = $e(this, this.list)), o = this.list.id), n = this.t(i); s.ariaControls = o, s.ariaLabel = s.ariaLabel || n } }, slides(t) { t.forEach((e, i) => O(e, { role: this.nav ? "tabpanel" : "group", "aria-label": this.t("slideLabel", i + 1, this.length), "aria-roledescription": this.nav ? null : "slide" })), this.padNavitems() } }, connected() { this.$el.role = this.role, this.$el.ariaRoleDescription = "carousel" }, update: [{ write() { this.navItems.concat(this.nav).forEach(t => t && (t.hidden = !this.maxIndex)), this.updateNav() }, events: ["resize"] }], events: [{ name: "click keydown", delegate: ({ selNavItem: t }) => t, filter: ({ parallax: t }) => !t, handler(t) { t.target.closest("a,button") && (t.type === "click" || t.keyCode === Y.SPACE) && (qt(t), this.show(mt(t.current, this.attrItem))) } }, { name: "itemshow", handler() { this.updateNav() } }, { name: "keydown", delegate: ({ selNavItem: t }) => t, filter: ({ parallax: t }) => !t, handler(t) { const { current: e, keyCode: i } = t, s = mt(e, this.attrItem); if (!Mt(s)) return; let n = i === Y.HOME ? 0 : i === Y.END ? "last" : i === Y.LEFT ? "previous" : i === Y.RIGHT ? "next" : -1; ~n && (t.preventDefault(), this.show(n)) } }], methods: { updateNav() { const t = this.getValidIndex(); for (const e of this.navItems) { const i = mt(e, this.attrItem), s = I("a,button", e) || e; if (Mt(i)) { const o = zt(i) === t; Z(e, this.clsActive, o), Z(s, "uk-disabled", !!this.parallax), s.ariaSelected = o, s.tabIndex = o && !this.parallax ? null : -1, o && s && R(W(e), ":focus-within") && s.focus() } else Z(e, "uk-invisible", this.finite && (i === "previous" && t === 0 || i === "next" && t >= this.maxIndex)) } }, padNavitems() { if (!this.nav) return; const t = []; for (let e = 0; e < this.length; e++) { const i = `${this.attrItem}="${e}"`; t[e] = this.navChildren.findLast(s => s.matches(`[${i}]`)) || I(`<li ${i}><a href></a></li>`) } ii(t, this.navChildren) || Dt(this.nav, t) } } }; const Kc = "cubic-bezier(0.25, 0.46, 0.45, 0.94)", Zc = "cubic-bezier(0.165, 0.84, 0.44, 1)"; var Er = { mixins: [_c, Ec, Jc, rs], props: { clsActivated: String, easing: String, index: Number, finite: Boolean, velocity: Number }, data: () => ({ easing: "ease", finite: !1, velocity: 1, index: 0, prevIndex: -1, stack: [], percent: 0, clsActive: "uk-active", clsActivated: "", clsEnter: "uk-slide-enter", clsLeave: "uk-slide-leave", clsSlideActive: "uk-slide-active", Transitioner: !1, transitionOptions: {} }), connected() { this.prevIndex = -1, this.index = this.getValidIndex(this.$props.index), this.stack = [] }, disconnected() { q(this.slides, this.clsActive) }, computed: { duration: ({ velocity: t }, e) => Cr(e.offsetWidth / t), list: ({ selList: t }, e) => I(t, e), maxIndex() { return this.length - 1 }, slides() { return X(this.list) }, length() { return this.slides.length } }, watch: { slides(t, e) { e && this.$emit() } }, events: { itemshow({ target: t }) { B(t, this.clsEnter, this.clsSlideActive) }, itemshown({ target: t }) { q(t, this.clsEnter) }, itemhide({ target: t }) { B(t, this.clsLeave) }, itemhidden({ target: t }) { q(t, this.clsLeave, this.clsSlideActive) } }, methods: { async show(t, e = !1) { var i; if (this.dragging || !this.length || this.parallax) return; const { stack: s } = this, n = e ? 0 : s.length, o = () => { s.splice(n, 1), s.length && this.show(s.shift(), !0) }; if (s[e ? "unshift" : "push"](t), !e && s.length > 1) { s.length === 2 && ((i = this._transitioner) == null || i.forward(Math.min(this.duration, 200))); return } const r = this.getIndex(this.index), a = T(this.slides, this.clsActive) && this.slides[r], c = this.getIndex(t, this.index), g = this.slides[c]; if (a === g) { o(); return } if (this.dir = Qc(t, r), this.prevIndex = r, this.index = c, a && !_(a, "beforeitemhide", [this]) || !_(g, "beforeitemshow", [this, a])) { this.index = this.prevIndex, o(); return } a && _(a, "itemhide", [this]), _(g, "itemshow", [this]), await this._show(a, g, e), a && _(a, "itemhidden", [this]), _(g, "itemshown", [this]), s.shift(), this._transitioner = null, await yi(), s.length && this.show(s.shift(), !0) }, getIndex(t = this.index, e = this.index) { return rt(kt(t, this.slides, e, this.finite), 0, Math.max(0, this.maxIndex)) }, getValidIndex(t = this.index, e = this.prevIndex) { return this.getIndex(t, e) }, async _show(t, e, i) { if (this._transitioner = this._getTransitioner(t, e, this.dir, { easing: i ? e.offsetWidth < 600 ? Kc : Zc : this.easing, ...this.transitionOptions }), !i && !t) { this._translate(1); return } const { length: s } = this.stack; return this._transitioner[s > 1 ? "forward" : "show"](s > 1 ? Math.min(this.duration, 75 + 75 / (s - 1)) : this.duration, this.percent) }, _translate(t, e = this.prevIndex, i = this.index) { const s = this._getTransitioner(e === i ? !1 : e, i); return s.translate(t), s }, _getTransitioner(t = this.prevIndex, e = this.index, i = this.dir || 1, s = this.transitionOptions) { return new this.Transitioner(ei(t) ? this.slides[t] : t, ei(e) ? this.slides[e] : e, i * (at ? -1 : 1), s) } } }; function Qc(t, e) { return t === "next" ? 1 : t === "previous" || t < e ? -1 : 1 } function Cr(t) { return .5 * t + 300 } var Pr = { mixins: [Er], props: { animation: String }, data: { animation: "slide", clsActivated: "uk-transition-active", Animations: wn, Transitioner: Sc }, computed: { animation({ animation: t, Animations: e }) { return { ...e[t] || e.slide, name: t } }, transitionOptions() { return { animation: this.animation } } }, observe: _t(), events: { itemshow({ target: t }) { B(t, this.clsActive) }, itemshown({ target: t }) { B(t, this.clsActivated) }, itemhidden({ target: t }) { q(t, this.clsActive, this.clsActivated) } } }, th = { ...wn, fade: { show() { return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }] }, percent(t) { return 1 - u(t, "opacity") }, translate(t) { return [{ opacity: 1 - t, zIndex: 0 }, { zIndex: -1 }] } }, scale: { show() { return [{ opacity: 0, transform: Fe(1 + .5), zIndex: 0 }, { zIndex: -1 }] }, percent(t) { return 1 - u(t, "opacity") }, translate(t) { return [{ opacity: 1 - t, transform: Fe(1 + .5 * t), zIndex: 0 }, { zIndex: -1 }] } }, pull: { show(t) { return t < 0 ? [{ transform: st(30), zIndex: -1 }, { transform: st(), zIndex: 0 }] : [{ transform: st(-100), zIndex: 0 }, { transform: st(), zIndex: -1 }] }, percent(t, e, i) { return i < 0 ? 1 - Si(e) : Si(t) }, translate(t, e) { return e < 0 ? [{ transform: st(30 * t), zIndex: -1 }, { transform: st(-100 * (1 - t)), zIndex: 0 }] : [{ transform: st(-t * 100), zIndex: 0 }, { transform: st(30 * (1 - t)), zIndex: -1 }] } }, push: { show(t) { return t < 0 ? [{ transform: st(100), zIndex: 0 }, { transform: st(), zIndex: -1 }] : [{ transform: st(-30), zIndex: -1 }, { transform: st(), zIndex: 0 }] }, percent(t, e, i) { return i > 0 ? 1 - Si(e) : Si(t) }, translate(t, e) { return e < 0 ? [{ transform: st(t * 100), zIndex: 0 }, { transform: st(-30 * (1 - t)), zIndex: -1 }] : [{ transform: st(-30 * t), zIndex: -1 }, { transform: st(100 * (1 - t)), zIndex: 0 }] } } }; function Fe(t) { return `scale3d(${t}, ${t}, 1)` } var Ir = { ...wn, fade: { show() { return [{ opacity: 0 }, { opacity: 1 }] }, percent(t) { return 1 - u(t, "opacity") }, translate(t) { return [{ opacity: 1 - t }, { opacity: t }] } }, scale: { show() { return [{ opacity: 0, transform: Fe(1 - .2) }, { opacity: 1, transform: Fe(1) }] }, percent(t) { return 1 - u(t, "opacity") }, translate(t) { return [{ opacity: 1 - t, transform: Fe(1 - .2 * t) }, { opacity: t, transform: Fe(1 - .2 + .2 * t) }] } } }, Tr = { i18n: { counter: "%s / %s" }, mixins: [bn, Pr], functional: !0, props: { counter: Boolean, preload: Number, nav: Boolean, slidenav: Boolean, delayControls: Number, videoAutoplay: Boolean, template: String }, data: () => ({ counter: !1, preload: 1, nav: !1, slidenav: !0, delayControls: 3e3, videoAutoplay: !1, items: [], cls: "uk-open", clsPage: "uk-lightbox-page", clsFit: "uk-lightbox-items-fit", clsZoom: "uk-lightbox-zoom", attrItem: "uk-lightbox-item", selList: ".uk-lightbox-items", selClose: ".uk-close-large", selNav: ".uk-lightbox-thumbnav, .uk-lightbox-dotnav", selCaption: ".uk-lightbox-caption", selCounter: ".uk-lightbox-counter", pauseOnHover: !1, velocity: 2, Animations: Ir, template: '<div class="uk-lightbox uk-overflow-hidden"> <div class="uk-lightbox-items"></div> <div class="uk-position-top-right uk-position-small uk-transition-fade" uk-inverse> <button class="uk-lightbox-close uk-close-large" type="button" uk-close></button> </div> <div class="uk-lightbox-slidenav uk-position-center-left uk-position-medium uk-transition-fade" uk-inverse> <a href uk-slidenav-previous uk-lightbox-item="previous"></a> </div> <div class="uk-lightbox-slidenav uk-position-center-right uk-position-medium uk-transition-fade" uk-inverse> <a href uk-slidenav-next uk-lightbox-item="next"></a> </div> <div class="uk-position-center-right uk-position-medium uk-transition-fade" uk-inverse style="max-height: 90vh; overflow: auto;"> <ul class="uk-lightbox-thumbnav uk-lightbox-thumbnav-vertical uk-thumbnav uk-thumbnav-vertical"></ul> <ul class="uk-lightbox-dotnav uk-dotnav uk-dotnav-vertical"></ul> </div> <div class="uk-lightbox-counter uk-text-large uk-position-top-left uk-position-small uk-transition-fade" uk-inverse></div> <div class="uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque"></div> </div>' }), created() { let t = I(this.template); Q(t, "template") && (t = Rt(Dt(t))); const e = I(this.selList, t), i = this.$props.nav; vt(G(this.selNav, t).filter(o => !R(o, `.uk-${i}`))); for (const [o, r] of this.items.entries()) it(e, "<div>"), i === "thumbnav" && ui(eh(r, this.videoAutoplay), it(I(this.selNav, t), `<li uk-lightbox-item="${o}"><a href></a></li>`)); this.slidenav || vt(G(".uk-lightbox-slidenav", t)), this.counter || vt(I(this.selCounter, t)), B(e, this.clsFit); const s = I("[uk-close]", t), n = this.t("close"); s && n && (s.dataset.i18n = JSON.stringify({ label: n })), this.$mount(it(this.container, t)) }, events: [{ name: "click", self: !0, filter: ({ bgClose: t }) => t, delegate: ({ selList: t }) => `${t} > *`, handler(t) { t.defaultPrevented || this.hide() } }, { name: "click", self: !0, delegate: ({ clsZoom: t }) => `.${t}`, handler(t) { t.defaultPrevented || Z(this.list, this.clsFit) } }, { name: `${ni} ${Ct} keydown`, filter: ({ delayControls: t }) => t, handler() { this.showControls() } }, { name: "shown", self: !0, handler() { this.showControls() } }, { name: "hide", self: !0, handler() { this.hideControls(), q(this.slides, this.clsActive), V.stop(this.slides) } }, { name: "hidden", self: !0, handler() { this.$destroy(!0) } }, { name: "keyup", el: () => document, handler({ keyCode: t }) { if (!this.isToggled() || !this.draggable) return; let e = -1; t === Y.LEFT ? e = "previous" : t === Y.RIGHT ? e = "next" : t === Y.HOME ? e = 0 : t === Y.END && (e = "last"), ~e && this.show(e) } }, { name: "beforeitemshow", handler(t) { Dt(I(this.selCaption, this.$el), this.getItem().caption || ""), Dt(I(this.selCounter, this.$el), this.t("counter", this.index + 1, this.slides.length)); for (let e = -this.preload; e <= this.preload; e++)this.loadItem(this.index + e); this.isToggled() || (this.draggable = !1, t.preventDefault(), this.toggleElement(this.$el, !0, !1), this.animation = Ir.scale, q(t.target, this.clsActive), this.stack.splice(1, 0, this.index)) } }, { name: "itemshown", handler() { this.draggable = this.$props.draggable } }, { name: "itemload", async handler(t, e) { const { source: i, type: s, attrs: n = {} } = e; if (this.setItem(e, "<span uk-spinner uk-inverse></span>"), !i) return; let o; const r = { allowfullscreen: "", style: "max-width: 100%; box-sizing: border-box;", "uk-responsive": "", "uk-video": !!this.videoAutoplay }; if (s === "image" || Mr(i)) { const a = Zt("img"); lr(a, e.sources), O(a, { src: i, ...Li(e, ["alt", "srcset", "sizes"]), ...n }), P(a, "load", () => this.setItem(e, W(a) || a)), P(a, "error", () => this.setError(e)) } else if (s === "video" || Or(i)) { const a = this.videoAutoplay === "inline", c = Zt("video", { src: i, playsinline: "", controls: a ? null : "", loop: a ? "" : null, muted: a ? "" : null, poster: this.videoAutoplay ? null : e.poster, "uk-video": !!this.videoAutoplay, ...n }); P(c, "loadedmetadata", () => this.setItem(e, c)), P(c, "error", () => this.setError(e)) } else if (s === "iframe" || i.match(/\.(html|php)($|\?)/i)) this.setItem(e, Zt("iframe", { src: i, allowfullscreen: "", class: "uk-lightbox-iframe", ...n })); else if (o = i.match(/\/\/(?:.*?youtube(-nocookie)?\..*?(?:[?&]v=|\/shorts\/)|youtu\.be\/)([\w-]{11})[&?]?(.*)?/)) this.setItem(e, Zt("iframe", { src: `https://www.youtube${o[1] || ""}.com/embed/${o[2]}${o[3] ? `?${o[3]}` : ""}`, width: 1920, height: 1080, ...r, ...n })); else if (o = i.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/)) try { const { height: a, width: c } = await (await fetch(`https://vimeo.com/api/oembed.json?maxwidth=1920&url=${encodeURI(i)}`, { credentials: "omit" })).json(); this.setItem(e, Zt("iframe", { src: `https://player.vimeo.com/video/${o[1]}${o[2] ? `?${o[2]}` : ""}`, width: c, height: a, ...r, ...n })) } catch { this.setError(e) } } }, { name: "itemloaded", handler() { this.$emit("resize") } }], update: { read() { for (const t of G(`${this.selList} :not([controls]):is(img,video)`, this.$el)) Z(t, this.clsZoom, (t.naturalHeight || t.videoHeight) - this.$el.offsetHeight > Math.max(0, (t.naturalWidth || t.videoWidth) - this.$el.offsetWidth)) }, events: ["resize"] }, methods: { loadItem(t = this.index) { const e = this.getItem(t); this.getSlide(e).childElementCount || _(this.$el, "itemload", [e]) }, getItem(t = this.index) { return this.items[kt(t, this.slides)] }, setItem(t, e) { _(this.$el, "itemloaded", [this, Dt(this.getSlide(t), e)]) }, getSlide(t) { return this.slides[this.items.indexOf(t)] }, setError(t) { this.setItem(t, '<span uk-icon="icon: bolt; ratio: 2" uk-inverse></span>') }, showControls() { clearTimeout(this.controlsTimer), this.controlsTimer = this.delayControls && setTimeout(this.hideControls, this.delayControls), B(this.$el, "uk-active", "uk-transition-active") }, hideControls() { q(this.$el, "uk-active", "uk-transition-active") } } }; function Zt(t, e) { const i = Rt(`<${t}>`); return O(i, e), i } function eh(t, e) { const i = t.poster || t.thumb && (t.type === "image" || Mr(t.thumb)) ? Zt("img", { src: t.poster || t.thumb, alt: "" }) : t.thumb && (t.type === "video" || Or(t.thumb)) ? Zt("video", { src: t.thumb, loop: "", playsinline: "", muted: "", "uk-video": e === "inline" }) : Zt("canvas"); return t.thumbRatio && (i.style.aspectRatio = t.thumbRatio), i } function Mr(t) { return t?.match(/\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\?)/i) } function Or(t) { return t?.match(/\.(mp4|webm|ogv)($|\?)/i) } const ih = ".uk-disabled *, .uk-disabled, [disabled]"; var sh = { install: nh, props: { toggle: String }, data: { toggle: "a" }, computed: { toggles: ({ toggle: t }, e) => G(t, e) }, watch: { toggles(t) { this.hide(); for (const e of t) Q(e, "a") && (e.role = "button") } }, disconnected() { this.hide() }, events: { name: "click", delegate: ({ toggle: t }) => t, handler(t) { t.defaultPrevented || (t.preventDefault(), R(t.current, ih) || this.show(t.current)) } }, methods: { show(t) { let e = this.toggles.map(Dr); if (this.nav === "thumbnav" && oh.call(this, this.toggles, e), e = go(e, "source"), _e(t)) { const { source: i } = Dr(t); t = H(e, ({ source: s }) => i === s) } return this.panel = this.panel || this.$create("lightboxPanel", { ...this.$props, items: e }), P(this.panel.$el, "hidden", () => this.panel = null), this.panel.show(t) }, hide() { var t; return (t = this.panel) == null ? void 0 : t.hide() } } }; function nh(t, e) { t.lightboxPanel || t.component("lightboxPanel", Tr), bt(e.props, t.component("lightboxPanel").options.props) } function oh(t, e) { for (const [i, s] of Object.entries(t)) { if (e[i].thumb) continue; const n = Te(s).reverse().concat(s).find(r => this.$el.contains(r) && (r === s || G(this.toggle, r).length === 1)); if (!n) continue; const o = I("img,video", n); o && (e[i].thumb = o.currentSrc || o.poster || o.src, e[i].thumbRatio = (o.naturalWidth || o.videoWidth) / (o.naturalHeight || o.videoHeight)) } } function Dr(t) { const e = {}; for (const i of t.getAttributeNames()) { const s = i.replace(/^data-/, ""); e[s === "href" ? "source" : s] = t.getAttribute(i) } return e.attrs = Be(e.attrs), e } var rh = { mixins: [ki], functional: !0, args: ["message", "status"], data: { message: "", status: "", timeout: 5e3, group: "", pos: "top-center", clsContainer: "uk-notification", clsClose: "uk-notification-close", clsMsg: "uk-notification-message" }, install: ah, computed: { marginProp: ({ pos: t }) => `margin-${t.match(/[a-z]+(?=-)/)[0]}`, startProps() { return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight } } }, created() { const t = `${this.clsContainer}-${this.pos}`, e = `data-${this.clsContainer}-container`, i = I(`.${t}[${e}]`, this.container) || it(this.container, `<div class="${this.clsContainer} ${t}" ${e}></div>`); this.$mount(it(i, `<div class="${this.clsMsg}${this.status ? ` ${this.clsMsg}-${this.status}` : ""}" role="alert"> <a href class="${this.clsClose}" data-uk-close></a> <div>${this.message}</div> </div>`)) }, async connected() { const t = N(u(this.$el, this.marginProp)); await V.start(u(this.$el, this.startProps), { opacity: 1, [this.marginProp]: t }), this.timeout && (this.timer = setTimeout(this.close, this.timeout)) }, events: { click(t) { qt(t), this.close() }, [Vt]() { this.timer && clearTimeout(this.timer) }, [Gt]() { this.timeout && (this.timer = setTimeout(this.close, this.timeout)) } }, methods: { async close(t) { const e = i => { const s = W(i); _(i, "close", [this]), vt(i), s?.hasChildNodes() || vt(s) }; this.timer && clearTimeout(this.timer), t || await V.start(this.$el, this.startProps), e(this.$el) } } }; function ah(t) { t.notification.closeAll = function (e, i) { Xt(document.body, s => { const n = t.getComponent(s, "notification"); n && (!e || e === n.group) && n.close(i) }) } } var cs = { props: { media: Boolean }, data: { media: !1 }, connected() { const t = lh(this.media, this.$el); if (this.matchMedia = !0, t) { this.mediaObj = window.matchMedia(t); const e = () => { this.matchMedia = this.mediaObj.matches, _(this.$el, Oe("mediachange", !1, !0, [this.mediaObj])) }; this.offMediaObj = P(this.mediaObj, "change", () => { e(), this.$emit("resize") }), e() } }, disconnected() { var t; (t = this.offMediaObj) == null || t.call(this) } }; function lh(t, e) { if (tt(t)) { if (J(t, "@")) t = N(u(e, `--uk-breakpoint-${t.slice(1)}`)); else if (isNaN(t)) return t } return t && Mt(t) ? `(min-width: ${t}px)` : "" } function Nr(t) { return et(t) ? Math.ceil(Math.max(0, ...G("[stroke]", t).map(e => { var i; return ((i = e.getTotalLength) == null ? void 0 : i.call(e)) || 0 }))) : 0 } const hs = { x: us, y: us, rotate: us, scale: us, color: Sn, backgroundColor: Sn, borderColor: Sn, blur: be, hue: be, fopacity: be, grayscale: be, invert: be, saturate: be, sepia: be, opacity: hh, stroke: uh, bgx: zr, bgy: zr }, { keys: Br } = Object; var Hr = { mixins: [cs], props: qr(Br(hs), "list"), data: qr(Br(hs), void 0), computed: { props(t, e) { const i = {}; for (const n in t) n in hs && !dt(t[n]) && (i[n] = t[n].slice()); const s = {}; for (const n in i) s[n] = hs[n](n, e, i[n], i); return s } }, events: { load() { this.$emit() } }, methods: { reset() { Ot(this.$el, this.getCss(0)) }, getCss(t) { const e = {}; for (const i in this.props) this.props[i](e, rt(t)); return e.willChange = Object.keys(e).map(Vi).join(","), e } } }; function us(t, e, i) { let s = fs(i) || { x: "px", y: "px", rotate: "deg" }[t] || "", n; return t === "x" || t === "y" ? (t = `translate${F(t)}`, n = o => N(N(o).toFixed(s === "px" ? 0 : 6))) : t === "scale" && (s = "", n = o => { var r; return fs([o]) ? ht(o, "width", e, !0) / e[`offset${(r = o.endsWith) != null && r.call(o, "vh") ? "Height" : "Width"}`] : N(o) }), i.length === 1 && i.unshift(t === "scale" ? 1 : 0), i = je(i, n), (o, r) => { o.transform = `${o.transform || ""} ${t}(${Ei(i, r)}${s})` } } function Sn(t, e, i) { return i.length === 1 && i.unshift(Ci(e, t, "")), i = je(i, s => ch(e, s)), (s, n) => { const [o, r, a] = Rr(i, n), c = o.map((g, m) => (g += a * (r[m] - g), m === 3 ? N(g) : parseInt(g, 10))).join(","); s[t] = `rgba(${c})` } } function ch(t, e) { return Ci(t, "color", e).split(/[(),]/g).slice(1, -1).concat(1).slice(0, 4).map(N) } function be(t, e, i) { i.length === 1 && i.unshift(0); const s = fs(i) || { blur: "px", hue: "deg" }[t] || "%"; return t = { fopacity: "opacity", hue: "hue-rotate" }[t] || t, i = je(i), (n, o) => { const r = Ei(i, o); n.filter = `${n.filter || ""} ${t}(${r + s})` } } function hh(t, e, i) { return i.length === 1 && i.unshift(Ci(e, t, "")), i = je(i), (s, n) => { s[t] = Ei(i, n) } } function uh(t, e, i) { i.length === 1 && i.unshift(0); const s = fs(i), n = Nr(e); return i = je(i.reverse(), o => (o = N(o), s === "%" ? o * n / 100 : o)), i.some(([o]) => o) ? (u(e, "strokeDasharray", n), (o, r) => { o.strokeDashoffset = Ei(i, r) }) : U } function zr(t, e, i, s) { i.length === 1 && i.unshift(0); const n = t === "bgy" ? "height" : "width"; s[t] = je(i, a => ht(a, n, e)); const o = ["bgx", "bgy"].filter(a => a in s); if (o.length === 2 && t === "bgx") return U; if (Ci(e, "backgroundSize", "") === "cover") return dh(t, e, i, s); const r = {}; for (const a of o) r[a] = Lr(e, a); return Fr(o, r, s) } function dh(t, e, i, s) { const n = fh(e); if (!n.width) return U; const o = { width: e.offsetWidth, height: e.offsetHeight }, r = ["bgx", "bgy"].filter(m => m in s), a = {}; for (const m of r) { const v = s[m].map(([D]) => D), w = Math.min(...v), A = Math.max(...v), M = v.indexOf(w) < v.indexOf(A), k = A - w; a[m] = `${(M ? -k : 0) - (M ? w : A)}px`, o[m === "bgy" ? "height" : "width"] += k } const c = Hs.cover(n, o); for (const m of r) { const v = m === "bgy" ? "height" : "width", w = c[v] - o[v]; a[m] = `max(${Lr(e, m)},-${w}px) + ${a[m]}` } const g = Fr(r, a, s); return (m, v) => { g(m, v), m.backgroundSize = `${c.width}px ${c.height}px`, m.backgroundRepeat = "no-repeat" } } function Lr(t, e) { return Ci(t, `background-position-${e.slice(-1)}`, "") } function Fr(t, e, i) { return function (s, n) { for (const o of t) { const r = Ei(i[o], n); s[`background-position-${o.slice(-1)}`] = `calc(${e[o]} + ${r}px)` } } } const jr = {}, ds = {}; function fh(t) { const e = u(t, "backgroundImage").replace(/^none|url\(["']?(.+?)["']?\)$/, "$1"); if (ds[e]) return ds[e]; const i = new Image; return e && (i.src = e, !i.naturalWidth && !jr[e]) ? (K(i, "error load", () => { ds[e] = _n(i), _(t, Oe("load", !1)) }), jr[e] = !0, _n(i)) : ds[e] = _n(i) } function _n(t) { return { width: t.naturalWidth, height: t.naturalHeight } } function je(t, e = N) { const i = [], { length: s } = t; let n = 0; for (let o = 0; o < s; o++) { let [r, a] = tt(t[o]) ? t[o].trim().split(/ (?![^(]*\))/) : [t[o]]; if (r = e(r), a = a ? N(a) / 100 : null, o === 0 ? a === null ? a = 0 : a && i.push([r, 0]) : o === s - 1 && (a === null ? a = 1 : a !== 1 && (i.push([r, a]), a = 1)), i.push([r, a]), a === null) n++; else if (n) { const c = i[o - n - 1][1], g = (a - c) / (n + 1); for (let m = n; m > 0; m--)i[o - m][1] = c + g * (n - m + 1); n = 0 } } return i } function Rr(t, e) { const i = H(t.slice(1), ([, s]) => e <= s) + 1; return [t[i - 1][0], t[i][0], (e - t[i - 1][1]) / (t[i][1] - t[i - 1][1])] } function Ei(t, e) { const [i, s, n] = Rr(t, e); return i + Math.abs(i - s) * n * (i < s ? 1 : -1) } const ph = /^-?\d+(?:\.\d+)?(\S+)?/; function fs(t, e) { var i; for (const s of t) { const n = (i = s.match) == null ? void 0 : i.call(s, ph); if (n) return n[1] } return e } function Ci(t, e, i) { const s = t.style[e], n = u(u(t, e, i), e); return t.style[e] = s, n } function qr(t, e) { return t.reduce((i, s) => (i[s] = e, i), {}) } function Ur(t, e) { return e >= 0 ? Math.pow(t, e + 1) : 1 - Math.pow(1 - t, 1 - e) } var gh = { mixins: [Hr], props: { target: String, viewport: Number, easing: Number, start: String, end: String }, data: { target: !1, viewport: 1, easing: 1, start: 0, end: 0 }, computed: { target: ({ target: t }, e) => Wr(t && ft(t, e) || e), start({ start: t }) { return ht(t, "height", this.target, !0) }, end({ end: t, viewport: e }) { return ht(t || (e = (1 - e) * 100) && `${e}vh+${e}%`, "height", this.target, !0) } }, observe: [hn(), wi({ target: ({ target: t }) => t }), _t({ target: ({ $el: t, target: e }) => [t, e, Kt(e, !0)] })], update: { read({ percent: t }, e) { if (e.has("scroll") || (t = !1), !et(this.$el)) return !1; if (!this.matchMedia) return; const i = t; return t = Ur(is(this.target, this.start, this.end), this.easing), { percent: t, style: i === t ? !1 : this.getCss(t) } }, write({ style: t }) { if (!this.matchMedia) { this.reset(); return } t && u(this.$el, t) }, events: ["scroll", "resize"] } }; function Wr(t) { return t ? "offsetTop" in t ? t : Wr(W(t)) : document.documentElement } var Vr = { props: { parallax: Boolean, parallaxTarget: Boolean, parallaxStart: String, parallaxEnd: String, parallaxEasing: Number }, data: { parallax: !1, parallaxTarget: !1, parallaxStart: 0, parallaxEnd: 0, parallaxEasing: 0 }, observe: [_t({ target: ({ $el: t, parallaxTarget: e }) => [t, e], filter: ({ parallax: t }) => t }), wi({ filter: ({ parallax: t }) => t })], computed: { parallaxTarget({ parallaxTarget: t }, e) { return t && ft(t, e) || this.list } }, update: { read() { if (!this.parallax) return !1; const t = this.parallaxTarget; if (!t) return !1; const e = ht(this.parallaxStart, "height", t, !0), i = ht(this.parallaxEnd, "height", t, !0), s = Ur(is(t, e, i), this.parallaxEasing); return { parallax: this.getIndexAt(s) } }, write({ parallax: t }) { const [e, i] = t, s = this.getValidIndex(e + Math.ceil(i)), n = this.slides[e], o = this.slides[s], { triggerShow: r, triggerShown: a, triggerHide: c, triggerHidden: g } = mh(this); if (~this.prevIndex) for (const v of new Set([this.index, this.prevIndex])) x([s, e], v) || (c(this.slides[v]), g(this.slides[v])); const m = this.prevIndex !== e || this.index !== s; this.dir = 1, this.prevIndex = e, this.index = s, n !== o && c(n), r(o), m && a(n), this._translate(n === o ? 1 : i, n, o) }, events: ["scroll", "resize"] }, methods: { getIndexAt(t) { const e = t * (this.length - 1); return [Math.floor(e), e % 1] } } }; function mh(t) { const { clsSlideActive: e, clsEnter: i, clsLeave: s } = t; return { triggerShow: n, triggerShown: o, triggerHide: r, triggerHidden: a }; function n(c) { T(c, s) && (r(c), a(c)), T(c, e) || (_(c, "beforeitemshow", [t]), _(c, "itemshow", [t])) } function o(c) { T(c, i) && _(c, "itemshown", [t]) } function r(c) { T(c, e) || n(c), T(c, i) && o(c), T(c, s) || (_(c, "beforeitemhide", [t]), _(c, "itemhide", [t])) } function a(c) { T(c, s) && _(c, "itemhidden", [t]) } } var Gr = { update: { write() { if (this.stack.length || this.dragging || this.parallax) return; const t = this.getValidIndex(); !~this.prevIndex || this.index !== t ? this.show(t) : this._translate(1) }, events: ["resize"] } }, Yr = { observe: ns({ target: ({ slides: t }) => t, targets: t => t.getAdjacentSlides() }), methods: { getAdjacentSlides() { return [1, -1].map(t => this.slides[this.getIndex(this.index + t)]) } } }; function vh(t, e, i, { center: s, easing: n, list: o }) { const r = t ? Pi(t, o, s) : Pi(e, o, s) + S(e).width * i, a = e ? Pi(e, o, s) : r + S(t).width * i * (at ? -1 : 1), { promise: c, resolve: g } = fr(); return { dir: i, show(m, v = 0, w) { const A = w ? "linear" : n; return m -= Math.round(m * rt(v, -1, 1)), u(o, "transitionProperty", "none"), this.translate(v), u(o, "transitionProperty", ""), v = t ? v : rt(v, 0, 1), me(this.getItemIn(), "itemin", { percent: v, duration: m, timing: A, dir: i }), t && me(this.getItemIn(!0), "itemout", { percent: 1 - v, duration: m, timing: A, dir: i }), V.start(o, { transform: st(-a * (at ? -1 : 1), "px") }, m, A).then(g, U), c }, cancel() { return V.cancel(o) }, reset() { u(o, "transform", "") }, async forward(m, v = this.percent()) { return await this.cancel(), this.show(m, v, !0) }, translate(m) { if (m === this.percent()) return; const v = this.getDistance() * i * (at ? -1 : 1); u(o, "transform", st(rt(-a + (v - v * m), -Re(o), S(o).width) * (at ? -1 : 1), "px")); const w = this.getActives(), A = this.getItemIn(), M = this.getItemIn(!0); m = t ? rt(m, -1, 1) : 0; for (const k of X(o)) { const D = x(w, k), ut = k === A, Tt = k === M, Nt = ut || !Tt && (D || i * (at ? -1 : 1) === -1 ^ ps(k, o) > ps(t || e)); me(k, `itemtranslate${Nt ? "in" : "out"}`, { dir: i, percent: Tt ? 1 - m : ut ? m : D ? 1 : 0 }) } }, percent() { return Math.abs((new DOMMatrix(u(o, "transform")).m41 * (at ? -1 : 1) + r) / (a - r)) }, getDistance() { return Math.abs(a - r) }, getItemIn(m = !1) { let v = this.getActives(), w = Jr(o, Pi(e || t, o, s)); if (m) { const A = v; v = w, w = A } return w[H(w, A => !x(v, A))] }, getActives() { return Jr(o, Pi(t || e, o, s)) } } } function Pi(t, e, i) { const s = ps(t, e); return i ? s - $h(t, e) : Math.min(s, Xr(e)) } function Xr(t) { return Math.max(0, Re(t) - S(t).width) } function Re(t, e) { return ae(X(t).slice(0, e), i => S(i).width) } function $h(t, e) { return S(e).width / 2 - S(t).width / 2 } function ps(t, e) { return t && (Ys(t).left + (at ? S(t).width - S(e).width : 0)) * (at ? -1 : 1) || 0 } function Jr(t, e) { e -= 1; const i = S(t).width, s = e + i + 2; return X(t).filter(n => { const o = ps(n, t), r = o + Math.min(S(n).width, i); return o >= e && r <= s }) } var bh = { mixins: [wt, Er, Gr, Vr, Yr], props: { center: Boolean, sets: Boolean, active: String }, data: { center: !1, sets: !1, attrItem: "uk-slider-item", selList: ".uk-slider-items", selNav: ".uk-slider-nav", clsContainer: "uk-slider-container", active: "all", Transitioner: vh }, computed: { finite({ finite: t }) { return t || wh(this.list, this.center) }, maxIndex() { if (!this.finite || this.center && !this.sets) return this.length - 1; if (this.center) return re(this.sets); let t = 0; const e = Xr(this.list), i = H(this.slides, s => { if (t >= e - .005) return !0; t += S(s).width }); return ~i ? i : this.length - 1 }, sets({ sets: t }) { if (!t || this.parallax) return; let e = 0; const i = [], s = S(this.list).width; for (let n = 0; n < this.length; n++) { const o = S(this.slides[n]).width; e + o > s && (e = 0), this.center ? e < s / 2 && e + o + S(this.slides[kt(n + 1, this.slides)]).width / 2 > s / 2 && (i.push(n), e = s / 2 - o / 2) : e === 0 && i.push(Math.min(n, this.maxIndex)), e += o } if (i.length) return i }, transitionOptions() { return { center: this.center, list: this.list } }, slides() { return X(this.list).filter(et) } }, connected() { Z(this.$el, this.clsContainer, !I(`.${this.clsContainer}`, this.$el)) }, observe: _t({ target: ({ slides: t, $el: e }) => [e, ...t] }), update: { write() { for (const t of this.navItems) { const e = zt(mt(t, this.attrItem)); e !== !1 && (t.hidden = !this.maxIndex || e > this.maxIndex || this.sets && !x(this.sets, e)) } this.reorder(), this.parallax || this._translate(1), this.updateActiveClasses() }, events: ["resize"] }, events: { beforeitemshow(t) { !this.dragging && this.sets && this.stack.length < 2 && !x(this.sets, this.index) && (this.index = this.getValidIndex()); const e = Math.abs(this.index - this.prevIndex + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)); if (!this.dragging && e > 1) { for (let n = 0; n < e; n++)this.stack.splice(1, 0, this.dir > 0 ? "next" : "previous"); t.preventDefault(); return } const i = this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex, s = Re(this.list) / this.length; this.duration = Cr(s / this.velocity) * (S(this.slides[i]).width / s), this.reorder() }, itemshow() { ~this.prevIndex && B(this._getTransitioner().getItemIn(), this.clsActive), this.updateActiveClasses(this.prevIndex) }, itemshown() { this.updateActiveClasses() } }, methods: { reorder() { if (this.finite) { u(this.slides, "order", ""); return } const t = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index; if (this.slides.forEach((n, o) => u(n, "order", this.dir > 0 && o < t ? 1 : this.dir < 0 && o >= this.index ? -1 : "")), !this.center || !this.length) return; const e = this.slides[t]; let i = S(this.list).width / 2 - S(e).width / 2, s = 0; for (; i > 0;) { const n = this.getIndex(--s + t, t), o = this.slides[n]; u(o, "order", n > t ? -2 : -1), i -= S(o).width } }, updateActiveClasses(t = this.index) { let e = this._getTransitioner(t).getActives(); this.active !== "all" && (e = [this.slides[this.getValidIndex(t)]]); const i = [this.clsActive, !this.sets || x(this.sets, N(this.index)) ? this.clsActivated : ""]; for (const s of this.slides) { const n = x(e, s); Z(s, i, n), s.ariaHidden = !n; for (const o of G(Ie, s)) f(o, "_tabindex") || (o._tabindex = o.tabIndex), o.tabIndex = n ? o._tabindex : -1 } }, getValidIndex(t = this.index, e = this.prevIndex) { if (t = this.getIndex(t, e), !this.sets) return t; let i; do { if (x(this.sets, t)) return t; i = t, t = this.getIndex(t + this.dir, e) } while (t !== i); return t }, getAdjacentSlides() { const { width: t } = S(this.list), e = -t, i = t * 2, s = S(this.slides[this.index]).width, n = this.center ? t / 2 - s / 2 : 0, o = new Set; for (const r of [-1, 1]) { let a = n + (r > 0 ? s : 0), c = 0; do { const g = this.slides[this.getIndex(this.index + r + c++ * r)]; a += S(g).width * r, o.add(g) } while (this.length > c && a > e && a < i) } return Array.from(o) }, getIndexAt(t) { let e = -1; const i = this.center ? Re(this.list) - (S(this.slides[0]).width / 2 + S(re(this.slides)).width / 2) : Re(this.list, this.maxIndex); let s = t * i, n = 0; do { const o = S(this.slides[++e]).width, r = this.center ? o / 2 + S(this.slides[e + 1]).width / 2 : o; n = s / r % 1, s -= r } while (s >= 0 && e < this.maxIndex); return [e, n] } } }; function wh(t, e) { if (!t || t.length < 2) return !0; const { width: i } = S(t); if (!e) return Math.ceil(Re(t)) < Math.trunc(i + xh(t)); const s = X(t), n = Math.trunc(i / 2); for (const o in s) { const r = s[o], a = S(r).width, c = new Set([r]); let g = 0; for (const m of [-1, 1]) { let v = a / 2, w = 0; for (; v < n;) { const A = s[kt(+o + m + w++ * m, s)]; if (c.has(A)) return !0; v += S(A).width, c.add(A) } g = Math.max(g, a / 2 + S(s[kt(+o + m, s)]).width / 2 - (v - n)) } if (Math.trunc(g) > ae(s.filter(m => !c.has(m)), m => S(m).width)) return !0 } return !1 } function xh(t) { return Math.max(0, ...X(t).map(e => S(e).width)) } var Kr = { mixins: [Hr], beforeConnect() { this.item = this.$el.closest(`.${this.$options.id.replace("parallax", "items")} > *`) }, disconnected() { this.item = null }, events: [{ name: "itemin itemout", self: !0, el: ({ item: t }) => t, handler({ type: t, detail: { percent: e, duration: i, timing: s, dir: n } }) { Jt.read(() => { if (!this.matchMedia) return; const o = this.getCss(Qr(t, n, e)), r = this.getCss(Zr(t) ? .5 : n > 0 ? 1 : 0); Jt.write(() => { u(this.$el, o), V.start(this.$el, r, i, s).catch(U) }) }) } }, { name: "transitioncanceled transitionend", self: !0, el: ({ item: t }) => t, handler() { V.cancel(this.$el) } }, { name: "itemtranslatein itemtranslateout", self: !0, el: ({ item: t }) => t, handler({ type: t, detail: { percent: e, dir: i } }) { Jt.read(() => { if (!this.matchMedia) { this.reset(); return } const s = this.getCss(Qr(t, i, e)); Jt.write(() => u(this.$el, s)) }) } }] }; function Zr(t) { return E(t, "in") } function Qr(t, e, i) { return i /= 2, Zr(t) ^ e < 0 ? i : 1 - i } var yh = { mixins: [wt, Pr, Gr, Vr, Yr], props: { ratio: String, minHeight: String, maxHeight: String }, data: { ratio: "16:9", minHeight: void 0, maxHeight: void 0, selList: ".uk-slideshow-items", attrItem: "uk-slideshow-item", selNav: ".uk-slideshow-nav", Animations: th }, watch: { list(t) { u(t, { aspectRatio: this.ratio ? this.ratio.replace(":", "/") : void 0, minHeight: this.minHeight, maxHeight: this.maxHeight, width: "100%" }) } }, methods: { getAdjacentSlides() { return [1, -1].map(t => this.slides[this.getIndex(this.index + t)]) } } }, kh = { mixins: [wt, nr], props: { group: String, threshold: Number, clsItem: String, clsPlaceholder: String, clsDrag: String, clsDragState: String, clsBase: String, clsNoDrag: String, clsEmpty: String, clsCustom: String, handle: String }, data: { group: !1, threshold: 5, clsItem: "uk-sortable-item", clsPlaceholder: "uk-sortable-placeholder", clsDrag: "uk-sortable-drag", clsDragState: "uk-drag", clsBase: "uk-sortable", clsNoDrag: "uk-sortable-nodrag", clsEmpty: "uk-sortable-empty", clsCustom: "", handle: !1, pos: {} }, events: { name: Ct, passive: !1, handler(t) { this.init(t) } }, computed: { target: (t, e) => (e.tBodies || [e])[0], items() { return X(this.target) }, isEmpty() { return !this.items.length }, handles({ handle: t }, e) { return t ? G(t, e) : this.items } }, watch: { isEmpty(t) { Z(this.target, this.clsEmpty, t) }, handles(t, e) { const i = { touchAction: "none", userSelect: "none" }; Ot(e, i), u(t, i) } }, update: { write(t) { if (!this.drag || !W(this.placeholder)) return; const { pos: { x: e, y: i }, origin: { offsetTop: s, offsetLeft: n }, placeholder: o } = this; u(this.drag, { top: i - s, left: e - n }); const r = this.getSortable(document.elementFromPoint(e, i)); if (!r) return; const { items: a } = r; if (a.some(V.inProgress)) return; const c = Eh(a, { x: e, y: i }); if (a.length && (!c || c === o)) return; const g = this.getSortable(o), m = Ch(r.target, c, o, e, i, r === g && t.moved !== c); m !== !1 && (m && o === m || (r !== g ? (g.remove(o), t.moved = c) : delete t.moved, r.insert(o, m), this.touched.add(r))) }, events: ["move"] }, methods: { init(t) { const { target: e, button: i, defaultPrevented: s } = t, [n] = this.items.filter(o => o.contains(e)); !n || s || i > 0 || Ui(e) || e.closest(`.${this.clsNoDrag}`) || this.handle && !e.closest(this.handle) || (t.preventDefault(), this.pos = jt(t), this.touched = new Set([this]), this.placeholder = n, this.origin = { target: e, index: Ft(n), ...this.pos }, P(document, ni, this.move), P(document, Wt, this.end), this.threshold || this.start(t)) }, start(t) { this.drag = Ah(this.$container, this.placeholder); const { left: e, top: i } = S(this.placeholder); bt(this.origin, { offsetLeft: this.pos.x - e, offsetTop: this.pos.y - i }), B(this.drag, this.clsDrag, this.clsCustom), B(this.placeholder, this.clsPlaceholder), B(this.items, this.clsItem), B(document.documentElement, this.clsDragState), _(this.$el, "start", [this, this.placeholder]), Sh(this.pos), this.move(t) }, move: Ih(function (t) { bt(this.pos, jt(t)), !this.drag && (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) && this.start(t), this.$emit("move") }), end() { if (he(document, ni, this.move), he(document, Wt, this.end), !this.drag) return; _h(); const t = this.getSortable(this.placeholder); this === t ? this.origin.index !== Ft(this.placeholder) && _(this.$el, "moved", [this, this.placeholder]) : (_(t.$el, "added", [t, this.placeholder]), _(this.$el, "removed", [this, this.placeholder])), _(this.$el, "stop", [this, this.placeholder]), vt(this.drag), this.drag = null; for (const { clsPlaceholder: e, clsItem: i } of this.touched) for (const s of this.touched) q(s.items, e, i); this.touched = null, q(document.documentElement, this.clsDragState) }, insert(t, e) { B(this.items, this.clsItem), e && e.previousElementSibling !== t ? this.animate(() => Yi(e, t)) : !e && this.target.lastElementChild !== t && this.animate(() => it(this.target, t)) }, remove(t) { this.target.contains(t) && this.animate(() => vt(t)) }, getSortable(t) { do { const e = this.$getComponent(t, "sortable"); if (e && (e === this || this.group !== !1 && e.group === this.group)) return e } while (t = W(t)) } } }; let ta; function Sh(t) { let e = Date.now(); ta = setInterval(() => { let { x: i, y: s } = t; s += document.scrollingElement.scrollTop; const n = (Date.now() - e) * .3; e = Date.now(), de(document.elementFromPoint(i, t.y)).reverse().some(o => { let { scrollTop: r, scrollHeight: a } = o; const { top: c, bottom: g, height: m } = xt(o); if (c < s && c + 35 > s) r -= n; else if (g > s && g - 35 < s) r += n; else return; if (r > 0 && r < a - m) return o.scrollTop = r, !0 }) }, 15) } function _h() { clearInterval(ta) } function Ah(t, e) { let i; if (Q(e, "li", "tr")) { i = I("<div>"), it(i, e.cloneNode(!0).children); for (const s of e.getAttributeNames()) O(i, s, e.getAttribute(s)) } else i = e.cloneNode(!0); return it(t, i), u(i, "margin", "0", "important"), u(i, { boxSizing: "border-box", width: e.offsetWidth, height: e.offsetHeight, padding: u(e, "padding") }), $t(i.firstElementChild, $t(e.firstElementChild)), i } function Eh(t, e) { return t[H(t, i => ji(e, S(i)))] } function Ch(t, e, i, s, n, o) { if (!X(t).length) return; const r = S(e); if (!o) return Ph(t, i) || n < r.top + r.height / 2 ? e : e.nextElementSibling; const a = S(i), c = ea([r.top, r.bottom], [a.top, a.bottom]), [g, m, v, w] = c ? [s, "width", "left", "right"] : [n, "height", "top", "bottom"], A = a[m] < r[m] ? r[m] - a[m] : 0; return a[v] < r[v] ? A && g < r[v] + A ? !1 : e.nextElementSibling : A && g > r[w] - A ? !1 : e } function Ph(t, e) { const i = X(t).length === 1; i && it(t, e); const s = X(t), n = s.some((o, r) => { const a = S(o); return s.slice(r + 1).some(c => { const g = S(c); return !ea([a.left, a.right], [g.left, g.right]) }) }); return i && vt(e), n } function ea(t, e) { return t[1] > e[0] && e[1] > t[0] } function Ih(t) { let e; return function (...i) { e || (e = !0, t.call(this, ...i), requestAnimationFrame(() => e = !1)) } } var Th = { mixins: [ki, ge, hr], data: { pos: "top", animation: ["uk-animation-scale-up"], duration: 100, cls: "uk-active" }, connected() { Mh(this.$el) }, disconnected() { this.hide() }, methods: { show() { if (this.isToggled(this.tooltip || null)) return; const { delay: t = 0, title: e } = Dh(this.$options); if (!e) return; const i = O(this.$el, "title"), s = P(this.$el, ["blur", Gt], o => !It(o) && this.hide()); this.reset = () => { O(this.$el, { title: i, "aria-describedby": null }), s() }; const n = $e(this); O(this.$el, { title: null, "aria-describedby": n }), clearTimeout(this.showTimer), this.showTimer = setTimeout(() => this._show(e, n), t) }, async hide() { var t; R(this.$el, "input:focus") || (clearTimeout(this.showTimer), this.isToggled(this.tooltip || null) && await this.toggleElement(this.tooltip, !1, !1), (t = this.reset) == null || t.call(this), vt(this.tooltip), this.tooltip = null) }, async _show(t, e) { this.tooltip = it(this.container, `<div id="${e}" class="uk-${this.$options.name}" role="tooltip"> <div class="uk-${this.$options.name}-inner">${t}</div> </div>`), P(this.tooltip, "toggled", (i, s) => { if (!s) return; const n = () => this.positionAt(this.tooltip, this.$el); n(); const [o, r] = Oh(this.tooltip, this.$el, this.pos); this.origin = this.axis === "y" ? `${Zi(o)}-${r}` : `${r}-${Zi(o)}`; const a = [K(document, `keydown ${Ct}`, this.hide, !1, c => c.type === Ct && !this.$el.contains(c.target) || c.type === "keydown" && c.keyCode === Y.ESC), P([document, ...fe(this.$el)], "scroll", n, { passive: !0 })]; K(this.tooltip, "hide", () => a.forEach(c => c()), { self: !0 }) }), await this.toggleElement(this.tooltip, !0) || this.hide() } }, events: { [`focus ${Vt} ${Ct}`](t) { (!It(t) || t.type === Ct) && document.readyState !== "loading" && this.show() } } }; function Mh(t) { ri(t) || (t.tabIndex = 0) } function Oh(t, e, [i, s]) { const n = L(t), o = L(e), r = [["left", "right"], ["top", "bottom"]]; for (const c of r) { if (n[c[0]] >= o[c[1]]) { i = c[1]; break } if (n[c[1]] <= o[c[0]]) { i = c[0]; break } } return s = (x(r[0], i) ? r[1] : r[0]).find(c => n[c] === o[c]) || "center", [i, s] } function Dh(t) { const { el: e, id: i, data: s } = t; return ["delay", "title"].reduce((n, o) => ({ [o]: mt(e, o), ...n }), { ...Be(mt(e, i), ["title"]), ...s }) } var Nh = { mixins: [rs], i18n: { invalidMime: "Invalid File Type: %s", invalidName: "Invalid File Name: %s", invalidSize: "Invalid File Size: %s Kilobytes Max" }, props: { allow: String, clsDragover: String, concurrent: Number, maxSize: Number, method: String, mime: String, multiple: Boolean, name: String, params: Object, type: String, url: String }, data: { allow: !1, clsDragover: "uk-dragover", concurrent: 1, maxSize: 0, method: "POST", mime: !1, multiple: !1, name: "files[]", params: {}, type: "", url: "", abort: U, beforeAll: U, beforeSend: U, complete: U, completeAll: U, error: U, fail: U, load: U, loadEnd: U, loadStart: U, progress: U }, events: { change(t) { R(t.target, 'input[type="file"]') && (t.preventDefault(), t.target.files && this.upload(t.target.files), t.target.value = "") }, drop(t) { gs(t); const e = t.dataTransfer; e?.files && (q(this.$el, this.clsDragover), this.upload(e.files)) }, dragenter(t) { gs(t) }, dragover(t) { gs(t), B(this.$el, this.clsDragover) }, dragleave(t) { gs(t), q(this.$el, this.clsDragover) } }, methods: { async upload(t) { if (t = pt(t), !t.length) return; _(this.$el, "upload", [t]); for (const s of t) { if (this.maxSize && this.maxSize * 1e3 < s.size) { this.fail(this.t("invalidSize", this.maxSize)); return } if (this.allow && !ia(this.allow, s.name)) { this.fail(this.t("invalidName", this.allow)); return } if (this.mime && !ia(this.mime, s.type)) { this.fail(this.t("invalidMime", this.mime)); return } } this.multiple || (t = t.slice(0, 1)), this.beforeAll(this, t); const e = Bh(t, this.concurrent), i = async s => { const n = new FormData; s.forEach(o => n.append(this.name, o)); for (const o in this.params) n.append(o, this.params[o]); try { const o = await Hh(this.url, { data: n, method: this.method, responseType: this.type, beforeSend: r => { const { xhr: a } = r; P(a.upload, "progress", this.progress); for (const c of ["loadStart", "load", "loadEnd", "abort"]) P(a, c.toLowerCase(), this[c]); return this.beforeSend(r) } }); this.complete(o), e.length ? await i(e.shift()) : this.completeAll(o) } catch (o) { this.error(o) } }; await i(e.shift()) } } }; function ia(t, e) { return e.match(new RegExp(`^${t.replace(/\//g, "\\/").replace(/\*\*/g, "(\\/[^\\/]+)*").replace(/\*/g, "[^\\/]+").replace(/((?!\\))\?/g, "$1.")}$`, "i")) } function Bh(t, e) { const i = []; for (let s = 0; s < t.length; s += e)i.push(t.slice(s, s + e)); return i } function gs(t) { t.preventDefault(), t.stopPropagation() } async function Hh(t, e) { const i = { data: null, method: "GET", headers: {}, xhr: new XMLHttpRequest, beforeSend: U, responseType: "", ...e }; return await i.beforeSend(i), zh(t, i) } function zh(t, e) { return new Promise((i, s) => { const { xhr: n } = e; for (const o in e) if (o in n) try { n[o] = e[o] } catch { } n.open(e.method.toUpperCase(), t); for (const o in e.headers) n.setRequestHeader(o, e.headers[o]); P(n, "load", () => { n.status === 0 || n.status >= 200 && n.status < 300 || n.status === 304 ? i(n) : s(bt(Error(n.statusText), { xhr: n, status: n.status })) }), P(n, "error", () => s(bt(Error("Network Error"), { xhr: n }))), P(n, "timeout", () => s(bt(Error("Network Timeout"), { xhr: n }))), n.send(e.data) }) } var Lh = Object.freeze({ __proto__: null, Countdown: Xl, Filter: ac, Lightbox: sh, LightboxPanel: Tr, Notification: rh, Parallax: gh, Slider: bh, SliderParallax: Kr, Slideshow: yh, SlideshowParallax: Kr, Sortable: kh, Tooltip: Th, Upload: Nh }); function Fh(t) { ce && window.MutationObserver && (document.body ? requestAnimationFrame(() => sa(t)) : new MutationObserver((e, i) => { document.body && (sa(t), i.disconnect()) }).observe(document.documentElement, { childList: !0 })) } function sa(t) { _(document, "uikit:init", t), document.body && Xt(document.body, na), new MutationObserver(jh).observe(document, { subtree: !0, childList: !0, attributes: !0 }), t._initialized = !0 } function jh(t) { var e; for (const { addedNodes: i, removedNodes: s, target: n, attributeName: o } of t) { for (const a of i) Xt(a, na); for (const a of s) Xt(a, Rh); const r = o && oa(o); r && (Lt(n, o) ? _i(r, n) : (e = ls(n, r)) == null || e.$destroy()) } } function na(t) { const e = Ai(t); for (const i in e) yn(e[i]); for (const i of t.getAttributeNames()) { const s = oa(i); s && _i(s, t) } } function Rh(t) { const e = Ai(t); for (const i in e) kn(e[i]) } function oa(t) { J(t, "data-") && (t = t.slice(5)); const e = Le[t]; return e && (e.options || e).name } Gc(At), Yc(At); var ra = { mixins: [wt, ge], props: { animation: Boolean, targets: String, active: null, collapsible: Boolean, multiple: Boolean, toggle: String, content: String, offset: Number }, data: { targets: "> *", active: !1, animation: !0, collapsible: !0, multiple: !1, clsOpen: "uk-open", toggle: "> .uk-accordion-title", content: "> .uk-accordion-content", offset: 0 }, computed: { items: ({ targets: t }, e) => G(t, e), toggles({ toggle: t }) { return this.items.map(e => I(t, e)) }, contents({ content: t }) { return this.items.map(e => { var i; return ((i = e._wrapper) == null ? void 0 : i.firstElementChild) || I(t, e) }) } }, watch: { items(t, e) { if (e || T(t, this.clsOpen)) return; const i = this.active !== !1 && t[Number(this.active)] || !this.collapsible && t[0]; i && this.toggle(i, !1) }, toggles() { this.$emit() }, contents(t) { for (const e of t) { const i = T(this.items.find(s => s.contains(e)), this.clsOpen); ms(e, !i) } this.$emit() } }, observe: ns(), events: [{ name: "click keydown", delegate: ({ targets: t, $props: e }) => `${t} ${e.toggle}`, async handler(t) { var e; t.type === "keydown" && t.keyCode !== Y.SPACE || (qt(t), (e = this._off) == null || e.call(this), this._off = Uh(t.target), await this.toggle(Ft(this.toggles, t.current)), this._off()) } }, { name: "shown hidden", self: !0, delegate: ({ targets: t }) => t, handler() { this.$emit() } }], update() { const t = ai(this.items, `.${this.clsOpen}`); for (const e in this.items) { const i = this.toggles[e], s = this.contents[e]; if (!i || !s) continue; i.id = $e(this, i), s.id = $e(this, s); const n = x(t, this.items[e]); O(i, { role: Q(i, "a") ? "button" : null, "aria-controls": s.id, "aria-expanded": n, "aria-disabled": !this.collapsible && t.length < 2 && n }), O(s, { role: "region", "aria-labelledby": i.id }), Q(s, "ul") && O(X(s), "role", "presentation") } }, methods: { toggle(t, e) { t = this.items[kt(t, this.items)]; let i = [t]; const s = ai(this.items, `.${this.clsOpen}`); if (!this.multiple && !x(s, i[0]) && (i = i.concat(s)), !(!this.collapsible && s.length < 2 && x(s, t))) return Promise.all(i.map(n => this.toggleElement(n, !x(s, n), (o, r) => { if (Z(o, this.clsOpen, r), e === !1 || !this.animation) { ms(I(this.content, o), !r); return } return qh(o, r, this) }))) } } }; function ms(t, e) { t && (t.hidden = e) } async function qh(t, e, { content: i, duration: s, velocity: n, transition: o }) { var r; i = ((r = t._wrapper) == null ? void 0 : r.firstElementChild) || I(i, t), t._wrapper || (t._wrapper = ui(i, "<div>")); const a = t._wrapper; u(a, "overflow", "hidden"); const c = N(u(a, "height")); await V.cancel(a), ms(i, !1); const g = ae(["marginTop", "marginBottom"], v => u(i, v)) + S(i).height, m = c / g; s = (n * g + s) * (e ? 1 - m : m), u(a, "height", c), await V.start(a, { height: e ? g : 0 }, s, o), di(i), delete t._wrapper, e || ms(i, !0) } function Uh(t) { const e = Kt(t, !0); let i; return (function s() { i = requestAnimationFrame(() => { const { top: n } = S(t); n < 0 && (e.scrollTop += n), s() }) })(), () => requestAnimationFrame(() => cancelAnimationFrame(i)) } var Wh = { mixins: [wt, ge], args: "animation", props: { animation: Boolean, close: String }, data: { animation: !0, selClose: ".uk-alert-close", duration: 150 }, events: { name: "click", delegate: ({ selClose: t }) => t, handler(t) { qt(t), this.close() } }, methods: { async close() { await this.toggleElement(this.$el, !1, Vh), this.$destroy(!0) } } }; function Vh(t, e, { duration: i, transition: s, velocity: n }) { const o = N(u(t, "height")); return u(t, "height", o), V.start(t, { height: 0, marginTop: 0, marginBottom: 0, paddingTop: 0, paddingBottom: 0, borderTop: 0, borderBottom: 0, opacity: 0 }, n * o + i, s) } var aa = { args: "autoplay", props: { automute: Boolean, autoplay: Boolean, restart: Boolean, hoverTarget: Boolean }, data: { automute: !1, autoplay: !0, restart: !1, hoverTarget: !1 }, beforeConnect() { const t = Q(this.$el, "video"); this.autoplay === "inview" && t && !Lt(this.$el, "preload") && (this.$el.preload = "none"), !t && !Lt(this.$el, "allow") && (this.$el.allow = "autoplay"), this.autoplay === "hover" && (t ? this.$el.tabIndex = 0 : this.autoplay = !0), (this.automute || Lt(this.$el, "muted")) && Bo(this.$el) }, events: [{ name: `${Vt} focusin`, el: ({ hoverTarget: t, $el: e }) => ft(t, e) || e, filter: ({ autoplay: t }) => x(t, "hover"), handler(t) { !It(t) || !Gh(this.$el) ? Qs(this.$el) : An(this.$el, this.restart) } }, { name: `${Gt} focusout`, el: ({ hoverTarget: t, $el: e }) => ft(t, e) || e, filter: ({ autoplay: t }) => x(t, "hover"), handler(t) { It(t) || An(this.$el, this.restart) } }], observe: [pe({ filter: ({ $el: t }) => t.preload === "none", handler([{ target: t }]) { t.preload = "", this.$reset() } }), pe({ filter: ({ $el: t, autoplay: e }) => e !== "hover" && t.preload !== "none", handler([{ isIntersecting: t, target: e }]) { document.fullscreenElement || (t ? this.autoplay && Qs(e) : An(e, this.restart)) }, args: { intersecting: !1 }, options: ({ $el: t, autoplay: e }) => ({ root: e === "inview" ? null : W(t).closest(":not(a)") }) })] }; function Gh(t) { return !t.paused && !t.ended } function An(t, e) { No(t), e && Q(t, "video") && (t.currentTime = 0) } var Yh = { mixins: [aa], props: { width: Number, height: Number }, data: { automute: !0 }, created() { this.useObjectFit = Q(this.$el, "img", "video") }, observe: _t({ target: ({ $el: t }) => la(t) || W(t), filter: ({ useObjectFit: t }) => !t }), update: { read() { if (this.useObjectFit) return !1; const { $el: t, width: e = t.clientWidth, height: i = t.clientHeight } = this, s = la(t) || W(t), n = Hs.cover({ width: e, height: i }, { width: s.offsetWidth, height: s.offsetHeight }); return n.width && n.height ? n : !1 }, write({ height: t, width: e }) { u(this.$el, { height: t, width: e }) }, events: ["resize"] } }; function la(t) { for (; t = W(t);)if (u(t, "position") !== "static") return t } let ct; var ca = { mixins: [wt, ki, hr, ge], args: "pos", props: { mode: "list", toggle: Boolean, boundary: Boolean, boundaryX: Boolean, boundaryY: Boolean, target: Boolean, targetX: Boolean, targetY: Boolean, stretch: Boolean, delayShow: Number, delayHide: Number, autoUpdate: Boolean, animateOut: Boolean, bgScroll: Boolean, closeOnScroll: Boolean }, data: { mode: ["click", "hover"], toggle: "- *", boundary: !1, boundaryX: !1, boundaryY: !1, target: !1, targetX: !1, targetY: !1, stretch: !1, delayShow: 0, delayHide: 800, autoUpdate: !0, animateOut: !1, bgScroll: !0, animation: ["uk-animation-fade"], cls: "uk-open", container: !1, closeOnScroll: !1, selClose: ".uk-drop-close" }, computed: { boundary({ boundary: t, boundaryX: e, boundaryY: i }, s) { return [ft(e || t, s) || window, ft(i || t, s) || window] }, target({ target: t, targetX: e, targetY: i }, s) { return e || (e = t || this.targetEl), i || (i = t || this.targetEl), [e === !0 ? window : ft(e, s), i === !0 ? window : ft(i, s)] } }, created() { this.tracker = new Mo }, connected() { B(this.$el, "uk-drop"), this.toggle && !this.targetEl && (this.targetEl = Jh(this)), O(this.targetEl, "aria-expanded", !1), this._style = Li(this.$el.style, ["width", "height"]) }, disconnected() { this.isActive() && (this.hide(!1), ct = null), u(this.$el, this._style) }, events: [{ name: "click", delegate: ({ selClose: t }) => t, handler(t) { qt(t), this.hide(!1) } }, { name: "click", delegate: () => 'a[href*="#"]', handler({ defaultPrevented: t, current: e }) { const { hash: i } = e; !t && i && Me(e) && !this.$el.contains(I(i)) && this.hide(!1) } }, { name: "beforescroll", handler() { this.hide(!1) } }, { name: "toggle", self: !0, handler(t, e) { t.preventDefault(), this.isToggled() ? this.hide(!1) : this.show(e?.$el, !1) } }, { name: "toggleshow", self: !0, handler(t, e) { t.preventDefault(), this.show(e?.$el) } }, { name: "togglehide", self: !0, handler(t) { t.preventDefault(), R(this.$el, ":focus,:hover") || this.hide() } }, { name: `${Vt} focusin`, filter: ({ mode: t }) => x(t, "hover"), handler(t) { It(t) || this.clearTimers() } }, { name: `${Gt} focusout`, filter: ({ mode: t }) => x(t, "hover"), handler(t) { !It(t) && t.relatedTarget && this.hide() } }, { name: "toggled", self: !0, handler(t, e) { e && (this.clearTimers(), this.position()) } }, { name: "show", self: !0, handler() { ct = this, this.tracker.init(), O(this.targetEl, "aria-expanded", !0); const t = [Kh(this), Zh(this), tu(this), this.autoUpdate && ha(this), this.closeOnScroll && Qh(this)]; K(this.$el, "hide", () => t.forEach(e => e && e()), { self: !0 }), this.bgScroll || K(this.$el, "hidden", cr(this.$el), { self: !0 }) } }, { name: "beforehide", self: !0, handler() { this.clearTimers() } }, { name: "hide", handler({ target: t }) { if (this.$el !== t) { ct = ct === null && this.$el.contains(t) && this.isToggled() ? this : ct; return } ct = this.isActive() ? null : ct, this.tracker.cancel(), O(this.targetEl, "aria-expanded", !1) } }], update: { write() { this.isToggled() && !T(this.$el, this.clsEnter) && this.position() } }, methods: { show(t = this.targetEl, e = !0) { if (this.isToggled() && t && this.targetEl && t !== this.targetEl && this.hide(!1, !1), this.targetEl = t, this.clearTimers(), !this.isActive()) { if (ct) { if (e && ct.isDelaying()) { this.showTimer = setTimeout(() => R(t, ":hover") && this.show(), 10); return } let i; for (; ct && i !== ct && !ct.$el.contains(this.$el);)i = ct, ct.hide(!1, !1); e = !1 } this.container && W(this.$el) !== this.container && it(this.container, this.$el), this.showTimer = setTimeout(() => this.toggleElement(this.$el, !0), e && this.delayShow || 0) } }, hide(t = !0, e = !0) { const i = () => this.toggleElement(this.$el, !1, this.animateOut && e); this.clearTimers(), this.isDelayedHide = t, t && this.isDelaying() ? this.hideTimer = setTimeout(this.hide, 50) : t && this.delayHide ? this.hideTimer = setTimeout(i, this.delayHide) : i() }, clearTimers() { clearTimeout(this.showTimer), clearTimeout(this.hideTimer), this.showTimer = null, this.hideTimer = null }, isActive() { return ct === this }, isDelaying() { return [this.$el, ...G(".uk-drop", this.$el)].some(t => this.tracker.movesTo(t)) }, position() { const t = os(this.$el); q(this.$el, "uk-drop-stack"), u(this.$el, this._style), this.$el.hidden = !0; const e = this.target.map(o => Xh(this.$el, o)), i = this.getViewportOffset(this.$el), s = [[0, ["x", "width", "left", "right"]], [1, ["y", "height", "top", "bottom"]]]; for (const [o, [r, a]] of s) this.axis !== r && x([r, !0], this.stretch) && u(this.$el, { [a]: Math.min(L(this.boundary[o])[a], e[o][a] - 2 * i), [`overflow-${r}`]: "auto" }); const n = e[0].width - 2 * i; this.$el.hidden = !1, u(this.$el, "maxWidth", ""), this.$el.offsetWidth > n && B(this.$el, "uk-drop-stack"), u(this.$el, "maxWidth", n), this.positionAt(this.$el, this.target, this.boundary); for (const [o, [r, a, c, g]] of s) if (this.axis === r && x([r, !0], this.stretch)) { const m = Math.abs(this.getPositionOffset()), v = L(this.target[o]), w = L(this.$el); u(this.$el, { [a]: (v[c] > w[c] ? v[this.inset ? g : c] - Math.max(L(this.boundary[o])[c], e[o][c] + i) : Math.min(L(this.boundary[o])[g], e[o][g] - i) - v[this.inset ? c : g]) - m, [`overflow-${r}`]: "auto" }), this.positionAt(this.$el, this.target, this.boundary) } t() } } }; function Xh(t, e) { return xt(fe(e).find(i => i.contains(t))) } function Jh(t) { const { $el: e } = t.$create("toggle", ft(t.toggle, t.$el), { target: t.$el, mode: t.mode }); return e.ariaHasPopup = !0, e } function Kh(t) { const e = () => t.$emit(), i = [Ks(e), gi(fe(t.$el).concat(t.target), e)]; return () => i.map(s => s.disconnect()) } function ha(t, e = () => t.$emit()) { return P([document, ...fe(t.$el)], "scroll", e, { passive: !0 }) } function Zh(t) { return P(document, "keydown", e => { e.keyCode === Y.ESC && t.hide(!1) }) } function Qh(t) { return ha(t, () => t.hide(!1)) } function tu(t) { return P(document, Ct, ({ target: e }) => { t.$el.contains(e) || K(document, `${Wt} ${qi} scroll`, ({ defaultPrevented: i, type: s, target: n }) => { var o; !i && s === Wt && e === n && !((o = t.targetEl) != null && o.contains(e)) && t.hide(!1) }, !0) }) } var ua = { mixins: [wt, ki], props: { align: String, boundary: Boolean, dropbar: Boolean, dropbarAnchor: Boolean, duration: Number, mode: Boolean, offset: Boolean, stretch: Boolean, delayShow: Boolean, delayHide: Boolean, target: Boolean, targetX: Boolean, targetY: Boolean, animation: Boolean, animateOut: Boolean, closeOnScroll: Boolean }, data: { align: at ? "right" : "left", clsDrop: "uk-dropdown", clsDropbar: "uk-dropnav-dropbar", boundary: !0, dropbar: !1, dropbarAnchor: !1, flip: !0, delayShow: 160, duration: 200, container: !1, selNavItem: "> li > a, > ul > li > a" }, computed: { dropbarAnchor: ({ dropbarAnchor: t }, e) => ft(t, e) || e, dropbar({ dropbar: t }) { return t ? (t = this._dropbar || ft(t, this.$el) || I(`+ .${this.clsDropbar}`, this.$el), t || (this._dropbar = I("<div>"))) : null }, dropContainer(t, e) { return this.container || e }, dropdowns({ clsDrop: t }, e) { var i; const s = G(`.${t}`, e); if (this.dropContainer !== e) for (const n of G(`.${t}`, this.dropContainer)) { const o = (i = this.getDropdown(n)) == null ? void 0 : i.targetEl; !x(s, n) && o && this.$el.contains(o) && s.push(n) } return s }, items({ selNavItem: t }, e) { return G(t, e) } }, watch: { dropbar(t) { B(t, "uk-dropbar", "uk-dropbar-top", this.clsDropbar, `uk-${this.$options.name}-dropbar`) }, dropdowns() { this.initializeDropdowns() } }, connected() { this.initializeDropdowns(), eu(this.$el) }, disconnected() { vt(this._dropbar), delete this._dropbar }, events: [{ name: "mouseover focusin", delegate: ({ selNavItem: t }) => t, handler({ current: t }) { const e = this.getActive(); e && x(e.mode, "hover") && e.targetEl && !t.contains(e.targetEl) && !e.isDelaying() && e.hide(!1) } }, { name: "keydown", self: !0, delegate: ({ selNavItem: t }) => t, handler(t) { var e; const { current: i, keyCode: s } = t, n = this.getActive(); if (s === Y.DOWN) if (n?.targetEl === i) t.preventDefault(), (e = I(Ie, n.$el)) == null || e.focus(); else { const o = this.dropdowns.find(r => { var a; return ((a = this.getDropdown(r)) == null ? void 0 : a.targetEl) === i }); o && (t.preventDefault(), i.click(), K(o, "show", r => { var a; return (a = I(Ie, r.target)) == null ? void 0 : a.focus() })) } da(t, this.items, n) } }, { name: "keydown", el: ({ dropContainer: t }) => t, delegate: ({ clsDrop: t }) => `.${t}`, handler(t) { var e; const { current: i, keyCode: s, target: n } = t; if (Ui(n) || !x(this.dropdowns, i)) return; const o = this.getActive(); let r = -1; if (s === Y.HOME ? r = 0 : s === Y.END ? r = "last" : s === Y.UP ? r = "previous" : s === Y.DOWN ? r = "next" : s === Y.ESC && ((e = o.targetEl) == null || e.focus()), ~r) { t.preventDefault(); const a = G(Ie, i); a[kt(r, a, H(a, c => R(c, ":focus")))].focus(); return } da(t, this.items, o) } }, { name: "mouseleave", el: ({ dropbar: t }) => t, filter: ({ dropbar: t }) => t, handler() { const t = this.getActive(); t && x(t.mode, "hover") && !this.dropdowns.some(e => R(e, ":hover")) && t.hide() } }, { name: "beforeshow", el: ({ dropContainer: t }) => t, filter: ({ dropbar: t }) => t, handler({ target: t }) { this.isDropbarDrop(t) && (this.dropbar.previousElementSibling !== this.dropbarAnchor && Xi(this.dropbarAnchor, this.dropbar), B(t, `${this.clsDrop}-dropbar`)) } }, { name: "show", el: ({ dropContainer: t }) => t, filter: ({ dropbar: t }) => t, handler({ target: t }) { if (!this.isDropbarDrop(t)) return; const e = this.getDropdown(t), i = () => { const s = Math.max(...Te(t, `.${this.clsDrop}`).concat(t).map(n => L(n).bottom)); L(this.dropbar, { left: L(this.dropbar).left, top: this.getDropbarOffset(e.getPositionOffset()) }), this.transitionTo(s - L(this.dropbar).top + N(u(t, "marginBottom")), t) }; this._observer = gi([e.$el, ...e.target], i), i() } }, { name: "beforehide", el: ({ dropContainer: t }) => t, filter: ({ dropbar: t }) => t, handler(t) { const e = this.getActive(); R(this.dropbar, ":hover") && e.$el === t.target && this.isDropbarDrop(e.$el) && x(e.mode, "hover") && e.isDelayedHide && !this.items.some(i => e.targetEl !== i && R(i, ":focus")) && t.preventDefault() } }, { name: "hide", el: ({ dropContainer: t }) => t, filter: ({ dropbar: t }) => t, handler({ target: t }) { var e; if (!this.isDropbarDrop(t)) return; (e = this._observer) == null || e.disconnect(); const i = this.getActive(); (!i || i.$el === t) && this.transitionTo(0) } }], methods: { getActive() { var t; return x(this.dropdowns, (t = ct) == null ? void 0 : t.$el) && ct }, async transitionTo(t, e) { const { dropbar: i } = this, s = $t(i); if (e = s < t && e, await V.cancel([e, i]), e) { const n = L(e).top - L(i).top - s; n > 0 && u(e, "transitionDelay", `${n / t * this.duration}ms`) } u(e, "clipPath", `polygon(0 0,100% 0,100% ${s}px,0 ${s}px)`), $t(i, s), await Promise.all([V.start(i, { height: t }, this.duration), V.start(e, { clipPath: `polygon(0 0,100% 0,100% ${t}px,0 ${t}px)` }, this.duration).finally(() => u(e, { clipPath: "", transitionDelay: "" }))]).catch(U) }, getDropdown(t) { return this.$getComponent(t, "drop") || this.$getComponent(t, "dropdown") }, isDropbarDrop(t) { return x(this.dropdowns, t) && T(t, this.clsDrop) }, getDropbarOffset(t) { const { $el: e, target: i, targetY: s } = this, { top: n, height: o } = L(ft(s || i || e, e)); return n + o + t }, initializeDropdowns() { this.$create("drop", this.dropdowns.filter(t => !this.getDropdown(t)), { ...this.$props, flip: this.flip && !this.$props.dropbar, shift: !0, pos: `bottom-${this.align}`, boundaryX: this.boundary === !0 ? this.$el : this.boundary }) } } }; function da(t, e, i) { var s, n, o; const { current: r, keyCode: a } = t; let c = -1; a === Y.HOME ? c = 0 : a === Y.END ? c = "last" : a === Y.LEFT ? c = "previous" : a === Y.RIGHT ? c = "next" : a === Y.TAB && ((s = i.targetEl) == null || s.focus(), (n = i.hide) == null || n.call(i, !1)), ~c && (t.preventDefault(), (o = i.hide) == null || o.call(i, !1), e[kt(c, e, e.indexOf(i.targetEl || r))].focus()) } function eu(t) { const e = () => i.forEach(s => s()), i = [K(t.ownerDocument, ni, s => t.contains(s.target) || e()), P(t, `mouseenter ${Vt}`, s => s.stopPropagation(), { capture: !0 }), P(t, `mouseleave ${Gt}`, e, { capture: !0 })] } var iu = { mixins: [wt], args: "target", props: { target: Boolean }, data: { target: !1 }, computed: { input: (t, e) => I(oi, e), state() { return this.input.nextElementSibling }, target({ target: t }, e) { return t && (t === !0 && W(this.input) === e && this.input.nextElementSibling || I(t, e)) } }, update() { var t; const { target: e, input: i } = this; if (!e) return; let s; const n = Ui(e) ? "value" : "textContent", o = e[n], r = (t = i.files) != null && t[0] ? i.files[0].name : R(i, "select") && (s = G("option", i).filter(a => a.selected)[0]) ? s.textContent : i.value; o !== r && (e[n] = r) }, events: [{ name: "change", handler() { this.$emit() } }, { name: "reset", el: ({ $el: t }) => t.closest("form"), handler() { this.$emit() } }] }, su = { extends: Zo, mixins: [wt], name: "grid", props: { masonry: Boolean, parallax: String, parallaxStart: String, parallaxEnd: String, parallaxJustify: Boolean }, data: { margin: "uk-grid-margin", clsStack: "uk-grid-stack", masonry: !1, parallax: 0, parallaxStart: 0, parallaxEnd: 0, parallaxJustify: !1 }, connected() { this.masonry && B(this.$el, "uk-flex-top", "uk-flex-wrap-top") }, observe: wi({ filter: ({ parallax: t, parallaxJustify: e }) => t || e }), update: [{ write({ rows: t }) { Z(this.$el, this.clsStack, !t.some(e => e.length > 1)) }, events: ["resize"] }, { read(t) { const { rows: e } = t; let { masonry: i, parallax: s, parallaxJustify: n, margin: o } = this; if (s = Math.max(0, ht(s)), !(i || s || n) || fa(e) || e[0].some((M, k) => e.some(D => D[k] && D[k].offsetWidth !== M.offsetWidth))) return t.translates = t.scrollColumns = !1; let r = ou(e, o), a, c; i ? [a, c] = nu(e, r, i === "next") : a = ru(e); const g = a.map(M => ae(M, "offsetHeight") + r * (M.length - 1)), m = Math.max(0, ...g); let v, w, A; return (s || n) && (v = g.map((M, k) => n ? m - M + s : s / (k % 2 || 8)), n || (s = Math.max(...g.map((M, k) => M + v[k] - m))), w = ht(this.parallaxStart, "height", this.$el, !0), A = ht(this.parallaxEnd, "height", this.$el, !0)), { columns: a, translates: c, scrollColumns: v, parallaxStart: w, parallaxEnd: A, padding: s, height: c ? m : "" } }, write({ height: t, padding: e }) { u(this.$el, "paddingBottom", e || ""), t !== !1 && u(this.$el, "height", t) }, events: ["resize"] }, { read({ rows: t, scrollColumns: e, parallaxStart: i, parallaxEnd: s }) { return { scrolled: e && !fa(t) ? is(this.$el, i, s) : !1 } }, write({ columns: t, scrolled: e, scrollColumns: i, translates: s }) { !e && !s || t.forEach((n, o) => n.forEach((r, a) => { let [c, g] = s && s[o][a] || [0, 0]; e && (g += e * i[o]), u(r, "transform", `translate(${c}px, ${g}px)`) })) }, events: ["scroll", "resize"] }] }; function fa(t) { return t.flat().some(e => u(e, "position") === "absolute") } function nu(t, e, i) { const s = [], n = [], o = Array(t[0].length).fill(0); let r = 0; for (let a of t) { at && a.reverse(); let c = 0; for (const g in a) { const { offsetWidth: m, offsetHeight: v } = a[g], w = i ? g : o.indexOf(Math.min(...o)); En(s, w, a[g]), En(n, w, [(w - g) * m * (at ? -1 : 1), o[w] - r]), o[w] += v + e, c = Math.max(c, v) } r += c + e } return [s, n] } function ou(t, e) { const i = t.flat().find(s => T(s, e)); return N(i ? u(i, "marginTop") : u(t[0][0], "paddingLeft")) } function ru(t) { const e = []; for (const i of t) for (const s in i) En(e, s, i[s]); return e } function En(t, e, i) { t[e] || (t[e] = []), t[e].push(i) } var au = { args: "target", props: { target: String, row: Boolean }, data: { target: "> *", row: !0 }, computed: { elements: ({ target: t }, e) => G(t, e) }, observe: _t({ target: ({ $el: t, elements: e }) => e.reduce((i, s) => i.concat(s, ...s.children), [t]) }), events: { name: "loadingdone", el: () => document.fonts, handler() { this.$emit("resize") } }, update: { read() { return { rows: (this.row ? un(this.elements) : [this.elements]).map(lu) } }, write({ rows: t }) { for (const { heights: e, elements: i } of t) i.forEach((s, n) => u(s, "minHeight", e[n])) }, events: ["resize"] } }; function lu(t) { if (t.length < 2) return { heights: [""], elements: t }; let e = t.map(cu); const i = Math.max(...e); return { heights: t.map((s, n) => e[n].toFixed(2) === i.toFixed(2) ? "" : i), elements: t } } function cu(t) { const e = Li(t.style, ["display", "minHeight"]); et(t) || u(t, "display", "block", "important"), u(t, "minHeight", ""); const i = S(t).height - De(t, "height", "content-box"); return u(t, e), i } var hu = { args: "target", props: { target: String }, data: { target: "" }, computed: { target: { get: ({ target: t }, e) => ft(t, e), observe: ({ target: t }) => t } }, observe: _t({ target: ({ target: t }) => t }), update: { read() { return this.target ? { height: this.target.offsetHeight } : !1 }, write({ height: t }) { u(this.$el, "minHeight", t) }, events: ["resize"] } }, uu = { props: { expand: Boolean, offsetTop: Boolean, offsetBottom: Boolean, min: Number, property: String }, data: { expand: !1, offsetTop: !1, offsetBottom: !1, min: 0, property: "min-height" }, observe: [hn({ filter: ({ expand: t }) => t }), _t({ target: ({ $el: t }) => de(t) })], update: { read() { if (!et(this.$el)) return !1; let t = ""; const e = De(this.$el, "height", "content-box"), { body: i, scrollingElement: s } = document, n = Kt(this.$el), { height: o } = xt(n === i ? s : n), r = s === n || i === n; if (t = `calc(${r ? "100vh" : `${o}px`}`, this.expand) { const a = S(n).height - S(this.$el).height; t += ` - ${a}px` } else { if (this.offsetTop) if (r) { const a = this.offsetTop === !0 ? this.$el : ft(this.offsetTop, this.$el), { top: c } = L(a); t += c > 0 && c < o / 2 ? ` - ${c}px` : "" } else t += ` - ${De(n, "height", u(n, "boxSizing"))}px`; this.offsetBottom === !0 ? t += ` - ${S(this.$el.nextElementSibling).height}px` : Mt(this.offsetBottom) ? t += ` - ${this.offsetBottom}vh` : this.offsetBottom && E(this.offsetBottom, "px") ? t += ` - ${N(this.offsetBottom)}px` : tt(this.offsetBottom) && (t += ` - ${S(ft(this.offsetBottom, this.$el)).height}px`) } return t += `${e ? ` - ${e}px` : ""})`, { minHeight: t } }, write({ minHeight: t }) { u(this.$el, this.property, `max(${this.min || 0}px, ${t})`) }, events: ["resize"] } }, du = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-x" viewBox="0 0 24 24"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>', fu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-x" viewBox="0 0 24 24"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>', pu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-chevron-down" viewBox="0 0 24 24"><path d="m6 9 6 6 6-6"/></svg>', gu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-plus" viewBox="0 0 24 24"><path d="M5 12h14"/><path d="M12 5v14"/></svg>', mu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-chevron-down" viewBox="0 0 24 24"><path d="m6 9 6 6 6-6"/></svg>', vu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-chevron-down" viewBox="0 0 24 24"><path d="m6 9 6 6 6-6"/></svg>', $u = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-chevron-down" viewBox="0 0 24 24"><path d="m6 9 6 6 6-6"/></svg>', bu = '<svg width="16" height="16" viewBox="0 0 20 20"><style>.uk-navbar-toggle-icon svg&gt;[class*=&quot;line-&quot;]{transition:0.2s ease-in-out;transition-property:transform, opacity;transform-origin:center;opacity:1}.uk-navbar-toggle-icon svg&gt;.line-3{opacity:0}[aria-expanded=&quot;true&quot;].uk-navbar-toggle-icon svg&gt;.line-3,[aria-expanded=&quot;true&quot;]&gt;.uk-navbar-toggle-icon svg&gt;.line-3{opacity:1}[aria-expanded=&quot;true&quot;].uk-navbar-toggle-icon svg&gt;.line-2,[aria-expanded=&quot;true&quot;]&gt;.uk-navbar-toggle-icon svg&gt;.line-2{transform:rotate(45deg)}[aria-expanded=&quot;true&quot;].uk-navbar-toggle-icon svg&gt;.line-3,[aria-expanded=&quot;true&quot;]&gt;.uk-navbar-toggle-icon svg&gt;.line-3{transform:rotate(-45deg)}[aria-expanded=&quot;true&quot;].uk-navbar-toggle-icon svg&gt;.line-1,[aria-expanded=&quot;true&quot;]&gt;.uk-navbar-toggle-icon svg&gt;.line-1,[aria-expanded=&quot;true&quot;].uk-navbar-toggle-icon svg&gt;.line-4,[aria-expanded=&quot;true&quot;]&gt;.uk-navbar-toggle-icon svg&gt;.line-4{opacity:0}[aria-expanded=&quot;true&quot;].uk-navbar-toggle-icon svg&gt;.line-1,[aria-expanded=&quot;true&quot;]&gt;.uk-navbar-toggle-icon svg&gt;.line-1{transform:translateY(6px) scaleX(0)}[aria-expanded=&quot;true&quot;].uk-navbar-toggle-icon svg&gt;.line-4,[aria-expanded=&quot;true&quot;]&gt;.uk-navbar-toggle-icon svg&gt;.line-4{transform:translateY(-6px) scaleX(0)}</style><rect width="20" height="2" y="3" class="line-1" rx="1"/><rect width="20" height="2" y="9" class="line-2" rx="1"/><rect width="20" height="2" y="9" class="line-3" rx="1"/><rect width="20" height="2" y="15" class="line-4" rx="1"/></svg>', wu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-plus" viewBox="0 0 24 24"><path d="M5 12h14"/><path d="M12 5v14"/></svg>', xu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-chevron-right" viewBox="0 0 24 24"><path d="m9 18 6-6-6-6"/></svg>', yu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-chevron-left" viewBox="0 0 24 24"><path d="m15 18-6-6 6-6"/></svg>', pa = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-search" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>', ku = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-search" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>', Su = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-search" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>', _u = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-arrow-right" viewBox="0 0 24 24"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>', Au = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-arrow-right" viewBox="0 0 24 24"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>', Eu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-arrow-left" viewBox="0 0 24 24"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>', Cu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-arrow-left" viewBox="0 0 24 24"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>', Pu = '<svg width="30" height="30"><circle fill="none" stroke="#000" cx="15" cy="15" r="14"/></svg>', Iu = '<svg width="16" height="16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" class="lucide lucide-circle-chevron-up" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="m8 14 4-4 4 4"/></svg>', ga = { args: "src", props: { width: Number, height: Number, ratio: Number }, data: { ratio: 1 }, connected() { this.svg = this.getSvg().then(t => { if (!this._connected) return; const e = Tu(t, this.$el); return this.svgEl && e !== this.svgEl && vt(this.svgEl), Mu.call(this, e, t), this.svgEl = e }, U) }, disconnected() { this.svg.then(t => { this._connected || (zs(this.$el) && (this.$el.hidden = !1), vt(t), this.svgEl = null) }), this.svg = null }, methods: { async getSvg() { } } }; function Tu(t, e) { if (zs(e) || Q(e, "canvas")) { e.hidden = !0; const s = e.nextElementSibling; return ma(t, s) ? s : Xi(e, t) } const i = e.lastElementChild; return ma(t, i) ? i : it(e, t) } function ma(t, e) { return Q(t, "svg") && Q(e, "svg") && t.innerHTML === e.innerHTML } function Mu(t, e) { const i = ["width", "height"]; let s = i.map(o => this[o]); s.some(o => o) || (s = i.map(o => O(e, o))); const n = O(e, "viewBox"); n && !s.some(o => o) && (s = n.split(" ").slice(2)), s.forEach((o, r) => O(t, i[r], N(o) * this.ratio || null)) } function va(t, e) { return e && x(t, "<symbol") && (t = Du(t)[e] || t), z(Rt(t)).filter(_e)[0] } const Ou = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g, Du = Et(function (t) { const e = {}; let i; for (; i = Ou.exec(t);)e[i[3]] = `<svg ${i[1]}svg>`; return e }), vs = { spinner: Pu, totop: Iu, marker: gu, "close-icon": du, "close-large": fu, "drop-parent-icon": pu, "nav-parent-icon": vu, "nav-parent-icon-large": mu, "navbar-parent-icon": $u, "navbar-toggle-icon": bu, "overlay-icon": wu, "pagination-next": xu, "pagination-previous": yu, "search-icon": pa, "search-medium": Su, "search-large": ku, "search-toggle-icon": pa, "slidenav-next": Au, "slidenav-next-large": _u, "slidenav-previous": Cu, "slidenav-previous-large": Eu }, Cn = { install: Uu, mixins: [ga], args: "icon", props: { icon: String }, isIcon: !0, beforeConnect() { B(this.$el, "uk-icon") }, async connected() { const t = await this.svg; t && (t.ariaHidden = !0) }, methods: { async getSvg() { const t = Vu(this.icon); if (!t) throw "Icon not found."; return t } } }, we = { args: !1, extends: Cn, data: t => ({ icon: b(t.constructor.options.name) }), beforeConnect() { B(this.$el, this.$options.id) } }, Nu = { extends: we, beforeConnect() { const t = this.$props.icon; this.icon = this.$el.closest(".uk-nav-primary") ? `${t}-large` : t } }, Bu = { extends: we, mixins: [rs], i18n: { toggle: "Open Search", submit: "Submit Search" }, beforeConnect() { const t = T(this.$el, "uk-search-toggle") || T(this.$el, "uk-navbar-toggle"); if (this.icon = t ? "search-toggle-icon" : T(this.$el, "uk-search-icon") && this.$el.closest(".uk-search-large") ? "search-large" : this.$el.closest(".uk-search-medium") ? "search-medium" : this.$props.icon, !Lt(this.$el, "aria-label")) if (t) this.$el.ariaLabel = this.t("toggle"); else { const e = this.$el.closest("a,button"); e && (e.ariaLabel = this.t("submit")) } } }, Hu = { extends: we, beforeConnect() { this.$el.role = "status" }, methods: { async getSvg() { const t = await Cn.methods.getSvg.call(this); return this.ratio !== 1 && u(I("circle", t), "strokeWidth", 1 / this.ratio), t } } }, xe = { extends: we, mixins: [rs], beforeConnect() { const t = this.$el.closest("a,button"); O(t, "role", this.role !== null && Q(t, "a") ? "button" : this.role); const e = this.t("label"); e && !Lt(t, "aria-label") && O(t, "aria-label", e) } }, $a = { extends: xe, beforeConnect() { B(this.$el, "uk-slidenav"); const t = this.$props.icon; this.icon = T(this.$el, "uk-slidenav-large") ? `${t}-large` : t } }, zu = { extends: xe, i18n: { label: "Open menu" }, beforeConnect() { const t = this.$el.closest("a,button"); t && (t.ariaExpanded = !1) } }, Lu = { extends: xe, i18n: { label: "Close" }, beforeConnect() { this.icon = `close-${T(this.$el, "uk-close-large") ? "large" : "icon"}` } }, Fu = { extends: xe, i18n: { label: "Open" } }, ju = { extends: xe, i18n: { label: "Back to top" } }, Ru = { extends: xe, i18n: { label: "Next page" }, data: { role: null } }, qu = { extends: xe, i18n: { label: "Previous page" }, data: { role: null } }, $s = {}; function Uu(t) { t.icon.add = (e, i) => { const s = tt(e) ? { [e]: i } : e; Ee(s, (n, o) => { vs[o] = n, delete $s[o] }), t._initialized && Xt(document.body, n => Ee(t.getComponents(n), o => { o.$options.isIcon && o.icon in s && o.$reset() })) } } const Wu = { twitter: "x" }; function Vu(t) { return t = Wu[t] || t, vs[t] ? ($s[t] || ($s[t] = va(vs[Gu(t)] || vs[t])), $s[t].cloneNode(!0)) : null } function Gu(t) { return at ? Ns(Ns(t, "left", "right"), "previous", "next") : t } var Yu = { props: { target: String, selActive: String }, data: { target: !1, selActive: !1 }, connected() { this.isIntersecting = 0 }, computed: { target: ({ target: t }, e) => t ? G(t, e) : e }, watch: { target: { handler() { queueMicrotask(() => this.$reset()) }, immediate: !1 } }, observe: [pe({ handler(t) { this.isIntersecting = t.reduce((e, { isIntersecting: i }) => e + (i ? 1 : this.isIntersecting ? -1 : 0), this.isIntersecting), this.$emit() }, target: ({ target: t }) => t, args: { intersecting: !1 } }), bi({ target: ({ target: t }) => t, options: { attributes: !0, attributeFilter: ["class"] } }), { target: ({ target: t }) => t, observe: (t, e) => { const i = gi([...z(t), document.documentElement], e), s = [P(document, "scroll itemshown itemhidden", e, { passive: !0, capture: !0 }), P(document, "show hide transitionstart", n => (e(), i.observe(n.target))), P(document, "shown hidden transitionend transitioncancel", n => (e(), i.unobserve(n.target)))]; return { observe: i.observe.bind(i), unobserve: i.unobserve.bind(i), disconnect() { i.disconnect(), s.map(n => n()) } } }, handler() { this.$emit() } }], update: { read() { if (!this.isIntersecting) return !1; for (const t of z(this.target)) { let e = !this.selActive || R(t, this.selActive) ? Xu(t) : ""; e !== !1 && Ri(t, "uk-light uk-dark", e) } } } }; function Xu(t) { const e = S(t), i = S(window); if (!Fi(e, i)) return !1; const { left: s, top: n, height: o, width: r } = e; let a; for (const c of [.25, .5, .75]) { const g = t.ownerDocument.elementsFromPoint(Math.max(0, Math.min(s + r * c, i.width - 1)), Math.max(0, Math.min(n + o / 2, i.height - 1))); for (const m of g) { if (t.contains(m) || !Ju(m) || m.closest('[class*="-leave"]') && g.some(w => m !== w && R(w, '[class*="-enter"]'))) continue; const v = u(m, "--uk-inverse"); if (v) { if (v === a) return `uk-${v}`; a = v; break } } } return a ? `uk-${a}` : "" } function Ju(t) { if (u(t, "visibility") !== "visible") return !1; for (; t;) { if (u(t, "opacity") === "0") return !1; t = W(t) } return !0 } var Ku = { mixins: [wt, cs], props: { fill: String }, data: { fill: "", clsWrapper: "uk-leader-fill", clsHide: "uk-leader-hide", attrFill: "data-fill" }, computed: { fill: ({ fill: t }, e) => t || u(e, "--uk-leader-fill-content") }, connected() { [this.wrapper] = Gs(this.$el, `<span class="${this.clsWrapper}">`) }, disconnected() { di(this.wrapper.childNodes) }, observe: _t(), update: { read() { return { width: Math.trunc(this.$el.offsetWidth / 2), fill: this.fill, hide: !this.matchMedia } }, write({ width: t, fill: e, hide: i }) { Z(this.wrapper, this.clsHide, i), O(this.wrapper, this.attrFill, new Array(t).join(e)) }, events: ["resize"] } }, Zu = { install: Qu, mixins: [bn], data: { clsPage: "uk-modal-page", selPanel: ".uk-modal-dialog", selClose: '[class*="uk-modal-close"]' }, events: [{ name: "fullscreenchange webkitendfullscreen", capture: !0, handler(t) { Q(t.target, "video") && this.isToggled() && !document.fullscreenElement && this.hide() } }, { name: "show", self: !0, handler() { T(this.panel, "uk-margin-auto-vertical") ? B(this.$el, "uk-flex") : u(this.$el, "display", "block"), $t(this.$el) } }, { name: "hidden", self: !0, handler() { u(this.$el, "display", ""), q(this.$el, "uk-flex") } }] }; function Qu({ modal: t }) { t.dialog = function (i, s) { const n = t(I(`<div><div class="uk-modal-dialog">${i}</div></div>`), { stack: !0, role: "alertdialog", ...s }); return n.show(), P(n.$el, "hidden", async () => { await Promise.resolve(), n.$destroy(!0) }, { self: !0 }), n }, t.alert = function (i, s) { return e(({ i18n: n }) => `<div class="uk-modal-body">${tt(i) ? i : Dt(i)}</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-btn uk-btn-primary uk-modal-close" type="button" autofocus>${n.ok}</button> </div>`, s) }, t.confirm = function (i, s) { return e(({ i18n: n }) => `<form> <div class="uk-modal-body">${tt(i) ? i : Dt(i)}</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-btn uk-btn-default uk-modal-close" type="button">${n.cancel}</button> <button class="uk-btn uk-btn-primary" autofocus>${n.ok}</button> </div> </form>`, s, () => Promise.reject()) }, t.prompt = function (i, s, n) { const o = e(({ i18n: c }) => `<form class="uk-form-stacked"> <div class="uk-modal-body"> <label>${tt(i) ? i : Dt(i)}</label> <input class="uk-input" autofocus> </div> <div class="uk-modal-footer uk-text-right"> <button class="uk-btn uk-btn-default uk-modal-close" type="button">${c.cancel}</button> <button class="uk-btn uk-btn-primary">${c.ok}</button> </div> </form>`, n, () => null, () => a.value), { $el: r } = o.dialog, a = I("input", r); return a.value = s || "", P(r, "show", () => a.select()), o }, t.i18n = { ok: "Ok", cancel: "Cancel" }; function e(i, s, n = U, o = U) { s = { bgClose: !1, escClose: !0, ...s, i18n: { ...t.i18n, ...s?.i18n } }; const r = t.dialog(i(s), s); return bt(new Promise(a => { const c = P(r.$el, "hide", () => a(n())); P(r.$el, "submit", "form", g => { g.preventDefault(), a(o(r)), c(), r.hide() }) }), { dialog: r }) } } var td = { extends: ra, data: { targets: "> .uk-parent", toggle: "> a", content: "> ul" } }; const Pn = "uk-navbar-transparent"; var ed = { extends: ua, props: { dropbarTransparentMode: Boolean }, data: { flip: !1, delayShow: 200, clsDrop: "uk-navbar-dropdown", selNavItem: ".uk-navbar-nav > li > a,a.uk-navbar-item,button.uk-navbar-item,.uk-navbar-item a,.uk-navbar-item button,.uk-navbar-toggle", dropbarTransparentMode: !1 }, computed: { navbarContainer: (t, e) => e.closest(".uk-navbar-container") }, watch: { items() { const t = T(this.$el, "uk-navbar-justify"), e = G(".uk-navbar-nav, .uk-navbar-left, .uk-navbar-right", this.$el); for (const i of e) { const s = t ? G(".uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle", i).length : ""; u(i, "flexGrow", s) } } }, events: [{ name: "show", el: ({ dropContainer: t }) => t, handler({ target: t }) { this.getTransparentMode(t) === "remove" && T(this.navbarContainer, Pn) && (q(this.navbarContainer, Pn), this._transparent = !0) } }, { name: "hide", el: ({ dropContainer: t }) => t, async handler() { await He(), this._transparent && (!ct || !this.dropContainer.contains(ct.$el)) && (B(this.navbarContainer, Pn), this._transparent = null) } }], methods: { getTransparentMode(t) { if (!this.navbarContainer) return; if (this.dropbar && this.isDropbarDrop(t)) return this.dropbarTransparentMode; const e = this.getDropdown(t); if (e && T(t, "uk-dropbar")) return e.inset ? "behind" : "remove" }, getDropbarOffset(t) { const { top: e, height: i } = L(this.navbarContainer); return e + (this.dropbarTransparentMode === "behind" ? 0 : i + t) } } }, id = { mixins: [bn], args: "mode", props: { mode: String, flip: Boolean, overlay: Boolean, swiping: Boolean }, data: { mode: "slide", flip: !1, overlay: !1, clsPage: "uk-offcanvas-page", clsContainer: "uk-offcanvas-container", selPanel: ".uk-offcanvas-bar", clsFlip: "uk-offcanvas-flip", clsContainerAnimation: "uk-offcanvas-container-animation", clsSidebarAnimation: "uk-offcanvas-bar-animation", clsMode: "uk-offcanvas", clsOverlay: "uk-offcanvas-overlay", selClose: ".uk-offcanvas-close", container: !1, swiping: !0 }, computed: { clsFlip: ({ flip: t, clsFlip: e }) => t ? e : "", clsOverlay: ({ overlay: t, clsOverlay: e }) => t ? e : "", clsMode: ({ mode: t, clsMode: e }) => `${e}-${t}`, clsSidebarAnimation: ({ mode: t, clsSidebarAnimation: e }) => t === "none" || t === "reveal" ? "" : e, clsContainerAnimation: ({ mode: t, clsContainerAnimation: e }) => t !== "push" && t !== "reveal" ? "" : e, transitionElement({ mode: t }) { return t === "reveal" ? W(this.panel) : this.panel } }, observe: Ko({ filter: ({ swiping: t }) => t }), update: { read() { this.isToggled() && !et(this.$el) && this.hide() }, events: ["resize"] }, events: [{ name: "touchmove", self: !0, passive: !1, filter: ({ overlay: t }) => t, handler(t) { t.cancelable && t.preventDefault() } }, { name: "show", self: !0, handler() { this.mode === "reveal" && !T(W(this.panel), this.clsMode) && B(ui(this.panel, "<div>"), this.clsMode); const { body: t, scrollingElement: e } = document; B(t, this.clsContainer, this.clsFlip), u(t, "touchAction", "pan-y pinch-zoom"), u(this.$el, "display", "block"), u(this.panel, "maxWidth", e.clientWidth), B(this.$el, this.clsOverlay), B(this.panel, this.clsSidebarAnimation, this.mode === "reveal" ? "" : this.clsMode), $t(t), B(t, this.clsContainerAnimation), this.clsContainerAnimation && sd() } }, { name: "hide", self: !0, handler() { q(document.body, this.clsContainerAnimation), u(document.body, "touchAction", "") } }, { name: "hidden", self: !0, handler() { this.clsContainerAnimation && nd(), this.mode === "reveal" && T(W(this.panel), this.clsMode) && di(this.panel), q(this.panel, this.clsSidebarAnimation, this.clsMode), q(this.$el, this.clsOverlay), u(this.$el, "display", ""), u(this.panel, "maxWidth", ""), q(document.body, this.clsContainer, this.clsFlip) } }, { name: "swipeLeft swipeRight", handler(t) { this.isToggled() && E(t.type, "Left") ^ this.flip && this.hide() } }] }; function sd() { ba().content += ",user-scalable=0" } function nd() { const t = ba(); t.content = t.content.replace(/,user-scalable=0$/, "") } function ba() { return I('meta[name="viewport"]', document.head) || it(document.head, '<meta name="viewport">') } var od = { mixins: [wt], props: { selContainer: String, selContent: String, minHeight: Number }, data: { selContainer: ".uk-modal", selContent: ".uk-modal-dialog", minHeight: 150 }, computed: { container: ({ selContainer: t }, e) => e.closest(t), content: ({ selContent: t }, e) => e.closest(t) }, observe: _t({ target: ({ container: t, content: e }) => [t, e] }), update: { read() { return !this.content || !this.container || !et(this.$el) ? !1 : { max: Math.max(this.minHeight, $t(this.container) - (S(this.content).height - $t(this.$el))) } }, write({ max: t }) { u(this.$el, { minHeight: this.minHeight, maxHeight: t }) }, events: ["resize"] } }, rd = { data: { fadeDuration: .05 }, events: { name: "scroll", self: !0, passive: !0, handler() { this.$emit() } }, observe: [bi({ options: { subtree: !0, childList: !0 } }), _t({ target: ({ $el: t }) => [t, ...X(t)] })], update: { read() { const t = []; for (const e of ["Width", "Height"]) t.push(this.$el[`scroll${e}`] - this.$el[`client${e}`]); return { overflow: t } }, write({ overflow: t }) { for (let e = 0; e < 2; e++)if (Z(this.$el, `${this.$options.id}-${e ? "vertical" : "horizontal"}`, t[e] && !t[e - 1]), !t[e - 1]) { const i = e ? "Top" : "Left", s = t[e] ? this.$el[`scroll${i}`] / t[e] : 0, n = o => t[e] ? rt((this.fadeDuration - o) / this.fadeDuration) : 1; u(this.$el, { "--uk-overflow-fade-start-opacity": n(s), "--uk-overflow-fade-end-opacity": n(1 - s) }) } }, events: ["resize"] } }, ad = { props: ["width", "height"], connected() { B(this.$el, "uk-responsive-width"), u(this.$el, "aspectRatio", `${this.width}/${this.height}`) } }, ld = { props: { offset: Number }, data: { offset: 0 }, connected() { cd(this) }, disconnected() { hd(this) }, methods: { async scrollTo(t) { t = t && I(t) || document.body, _(this.$el, "beforescroll", [this, t]) && (await Fo(t, { offset: this.offset }), _(this.$el, "scrolled", [this, t])) } } }; const Ii = new Set; function cd(t) { Ii.size || P(document, "click", wa), Ii.add(t) } function hd(t) { Ii.delete(t), Ii.size || he(document, "click", wa) } function wa(t) { if (!t.defaultPrevented) for (const e of Ii) e.$el.contains(t.target) && Me(e.$el) && (t.preventDefault(), window.location.href !== e.$el.href && window.history.pushState({}, "", e.$el.href), e.scrollTo(Wi(e.$el))) } const In = "uk-scrollspy-inview"; var ud = { args: "cls", props: { cls: String, target: String, hidden: Boolean, margin: String, repeat: Boolean, delay: Number }, data: () => ({ cls: "", target: !1, hidden: !0, margin: "-1px", repeat: !1, delay: 0 }), computed: { elements: ({ target: t }, e) => t ? G(t, e) : [e] }, watch: { elements(t) { this.hidden && u(ai(t, `:not(.${In})`), "opacity", 0) } }, connected() { this.elementData = new Map }, disconnected() { for (const [t, e] of this.elementData.entries()) q(t, In, e.cls || ""); delete this.elementData }, observe: pe({ target: ({ elements: t }) => t, handler(t) { const e = this.elementData; for (const { target: i, isIntersecting: s } of t) { e.has(i) || e.set(i, { cls: mt(i, "uk-scrollspy-class") || this.cls }); const n = e.get(i); !this.repeat && n.show || (n.show = s) } this.$emit() }, options: ({ margin: t }) => ({ rootMargin: t }), args: { intersecting: !1 } }), update: [{ write(t) { for (const [e, i] of this.elementData.entries()) i.show && !i.inview && !i.queued ? (i.queued = !0, t.promise = (t.promise || Promise.resolve()).then(async () => { await He(i.show ? this.delay : 0), this.toggle(e, !0), setTimeout(() => { i.queued = !1, this.$emit() }, 300) })) : !i.show && i.inview && !i.queued && this.repeat && this.toggle(e, !1) } }], methods: { toggle(t, e) { var i, s; const n = (i = this.elementData) == null ? void 0 : i.get(t); if (!n) return; (s = n.off) == null || s.call(n), u(t, "opacity", !e && this.hidden ? 0 : ""), Z(t, In, e), Z(t, n.cls); let o; if (o = n.cls.match(/\buk-animation-[\w-]+/g)) { const r = () => q(t, o); e ? n.off = K(t, "animationcancel animationend", r, { self: !0 }) : r() } _(t, e ? "inview" : "outview"), n.inview = e } } }, dd = { props: { cls: String, closest: Boolean, scroll: Boolean, target: String, offset: Number }, data: { cls: "uk-active", closest: !1, scroll: !1, target: 'a[href]:not([role="button"])', offset: 0 }, computed: { links: { get({ target: t }, e) { return G(t, e).filter(Wi) }, observe: () => "*" }, targets() { return this.links.map(t => Wi(t)) }, elements({ closest: t }) { return this.links.map(e => e.closest(t || "*")) } }, watch: { links(t) { this.scroll && this.$create("scroll", t, { offset: this.offset }) } }, observe: [pe(), wi()], update: [{ read() { const { targets: t } = this, { length: e } = t; if (!e || !et(this.$el)) return !1; const i = Kt(t, !0), { scrollTop: s, scrollHeight: n } = i, o = xt(i), r = n - o.height; let a = !1; if (s >= r) a = e - 1; else { const c = this.offset + S(nn()).height + o.height * .1; for (let g = 0; g < t.length && !(L(t[g]).top - o.top - c > 0); g++)a = +g } return { active: a } }, write({ active: t }) { const { elements: e } = this, i = t !== !1 && !T(e[t], this.cls); this.links.forEach(s => s.blur()); for (let s = 0; s < e.length; s++)Z(e[s], this.cls, +s === t); i && _(this.$el, "active", [t, e[t]]) }, events: ["scroll", "resize"] }] }, fd = { mixins: [wt, cs], props: { position: String, top: null, bottom: null, start: null, end: null, offset: String, offsetEnd: String, overflowFlip: Boolean, animation: String, clsActive: String, clsInactive: String, clsFixed: String, clsBelow: String, selTarget: String, showOnUp: Boolean, targetOffset: Number }, data: { position: "top", top: !1, bottom: !1, start: !1, end: !1, offset: 0, offsetEnd: 0, overflowFlip: !1, animation: "", clsActive: "uk-active", clsInactive: "", clsFixed: "uk-sticky-fixed", clsBelow: "uk-sticky-below", selTarget: "", showOnUp: !1, targetOffset: !1 }, computed: { target: ({ selTarget: t }, e) => t && I(t, e) || e }, connected() { this.start = xa(this.start || this.top), this.end = xa(this.end || this.bottom), this.placeholder = I("+ .uk-sticky-placeholder", this.$el) || I('<div class="uk-sticky-placeholder"></div>'), this.isFixed = !1, this.setActive(!1) }, beforeDisconnect() { this.isFixed && (this.hide(), q(this.target, this.clsInactive)), Mn(this.$el), vt(this.placeholder), this.placeholder = null }, observe: [hn(), wi({ target: () => document.scrollingElement }), _t({ target: ({ $el: t }) => [t, bs(t), document.scrollingElement], handler(t) { this.$emit(this._data.resized && t.some(({ target: e }) => e === bs(this.$el)) ? "update" : "resize"), this._data.resized = !0 } })], events: [{ name: "load hashchange popstate", el: () => window, filter: ({ targetOffset: t }) => t !== !1, async handler() { const { scrollingElement: t } = document; if (!location.hash || t.scrollTop === 0) return; await He(); const e = L(I(location.hash)), i = L(this.$el); this.isFixed && Fi(e, i) && (t.scrollTop = Math.ceil(e.top - i.height - ht(this.targetOffset, "height", this.placeholder) - ht(this.offset, "height", this.placeholder))) } }], update: [{ read({ height: t, width: e, margin: i, sticky: s }, n) { if (this.inactive = !this.matchMedia || !et(this.$el) || !this.$el.offsetHeight, this.inactive) return; const o = $t(window), r = Math.max(0, document.scrollingElement.scrollHeight - o); if (!r) { this.inactive = !0; return } const a = this.isFixed && n.has("update"); a && (Dn(this.target), this.hide()), this.active || ({ height: t, width: e } = S(this.$el), i = u(this.$el, "margin")), a && this.show(); const c = ht("100vh", "height"); let g = this.position; this.overflowFlip && t > c && (g = g === "top" ? "bottom" : "top"); const m = this.isFixed ? this.placeholder : this.$el; let [v, w] = [this.offset, this.offsetEnd].map(Nt => ht(Nt, "height", s ? this.$el : m)); g === "bottom" && (t < o || this.overflowFlip) && (v += o - t); const A = t + v + w, M = this.overflowFlip ? 0 : Math.max(0, A - c), k = L(m).top - new DOMMatrix(u(m, "transform")).m42, D = S(this.$el).height, ut = (this.start === !1 ? k : Tn(this.start, this.$el, k)) - v, Tt = this.end === !1 ? r : Math.min(r, Tn(this.end, this.$el, k + t, !0) - D - v + M); return s = !this.showOnUp && ut + v === k && Tt === Math.min(r, Tn(!0, this.$el, 0, !0) - D - v + M) && u(bs(this.$el), "overflowY") !== "hidden", { start: ut, end: Tt, offset: v, overflow: M, height: t, elHeight: D, width: e, margin: i, top: fi(m)[0], sticky: s, viewport: c, maxScrollHeight: r } }, write({ height: t, width: e, margin: i, offset: s, sticky: n }) { if ((this.inactive || n || !this.isFixed) && Mn(this.$el), this.inactive) return; n && (t = e = i = 0, u(this.$el, { position: "sticky", top: s })); const { placeholder: o } = this; u(o, { height: t, width: e, margin: i }), (W(o) !== W(this.$el) || n ^ Ft(o) < Ft(this.$el)) && ((n ? Yi : Xi)(this.$el, o), o.hidden = !0) }, events: ["resize"] }, { read({ scroll: t = 0, dir: e = "down", overflow: i, overflowScroll: s = 0, start: n, end: o, elHeight: r, height: a, sticky: c, maxScrollHeight: g }) { const m = Math.min(document.scrollingElement.scrollTop, g), v = t <= m ? "down" : "up", w = this.isFixed ? this.placeholder : this.$el; return { dir: v, prevDir: e, scroll: m, prevScroll: t, below: m > L(w).top + (c ? Math.min(a, r) : a), offsetParentTop: L(w.offsetParent).top, overflowScroll: rt(s + rt(m, n, o) - rt(t, n, o), 0, i) } }, write(t, e) { const i = e.has("scroll"), { initTimestamp: s = 0, dir: n, prevDir: o, scroll: r, prevScroll: a = 0, top: c, start: g, below: m } = t; if (r < 0 || r === a && i || this.showOnUp && !i && !this.isFixed) return; const v = Date.now(); if ((v - s > 300 || n !== o) && (t.initScroll = r, t.initTimestamp = v), !(this.showOnUp && !this.isFixed && Math.abs(t.initScroll - r) <= 30 && Math.abs(a - r) <= 10)) if (this.inactive || r < g || this.showOnUp && (r <= g || n === "down" && i || n === "up" && !this.isFixed && !m)) { if (!this.isFixed) { Yt.inProgress(this.$el) && c > r && (Yt.cancel(this.$el), this.hide()); return } if (this.animation && m) { if (T(this.$el, "uk-animation-leave")) return; Yt.out(this.$el, this.animation).then(() => this.hide(), U) } else this.hide() } else this.isFixed ? this.update() : this.animation && m ? (this.show(), Yt.in(this.$el, this.animation).catch(U)) : (Dn(this.target), this.show()) }, events: ["resize", "resizeViewport", "scroll"] }], methods: { show() { this.isFixed = !0, this.update(), this.placeholder.hidden = !1 }, hide() { const { offset: t, sticky: e } = this._data; this.setActive(!1), q(this.$el, this.clsFixed, this.clsBelow), e ? u(this.$el, "top", t) : Mn(this.$el), this.placeholder.hidden = !0, this.isFixed = !1 }, update() { let { width: t, scroll: e = 0, overflow: i, overflowScroll: s = 0, start: n, end: o, offset: r, offsetParentTop: a, sticky: c, below: g } = this._data; const m = n !== 0 || e > n; if (!c) { let v = "fixed"; e > o && (r += o - a + s - i, v = "absolute"), u(this.$el, { position: v, width: t, marginTop: 0 }, "important") } u(this.$el, "top", r - s), this.setActive(m), Z(this.$el, this.clsBelow, g), B(this.$el, this.clsFixed) }, setActive(t) { const e = this.active; this.active = t, t ? (Ri(this.target, this.clsInactive, this.clsActive), e !== t && _(this.$el, "active")) : (Ri(this.target, this.clsActive, this.clsInactive), e !== t && (Dn(this.target), _(this.$el, "inactive"))) } } }; function Tn(t, e, i, s) { if (!t) return 0; if (Mt(t) || tt(t) && t.match(/^-?\d/)) return i + ht(t, "height", e, !0); { const n = t === !0 ? bs(e) : ft(t, e); return L(n).bottom - (s && n?.contains(e) ? N(u(n, "paddingBottom")) + N(u(n, "borderBottomWidth")) : 0) } } function xa(t) { return t === "true" ? !0 : t === "false" ? !1 : t } function Mn(t) { u(t, { position: "", top: "", marginTop: "", width: "" }) } const On = "uk-transition-disable"; async function Dn(t) { T(t, On) || (B(t, On), await yi(), q(t, On)) } function bs(t) { for (; t = W(t);)if (et(t)) return t } var pd = { mixins: [ga], args: "src", props: { src: String, icon: String, attributes: "list", strokeAnimation: Boolean }, data: { strokeAnimation: !1 }, observe: [bi({ async handler() { const t = await this.svg; t && ya.call(this, t) }, options: { attributes: !0, attributeFilter: ["id", "class", "style"] } })], async connected() { x(this.src, "#") && ([this.src, this.icon] = this.src.split("#", 2)); const t = await this.svg; t && (ya.call(this, t), this.strokeAnimation && md(t)) }, methods: { async getSvg() { return Q(this.$el, "img") && !this.$el.complete && this.$el.loading === "lazy" && await new Promise(t => K(this.$el, "load", t)), va(await gd(this.src), this.icon) || Promise.reject("SVG not found.") } } }; function ya(t) { const { $el: e } = this; B(t, O(e, "class"), "uk-svg"); for (let i = 0; i < e.style.length; i++) { const s = e.style[i]; u(t, s, u(e, s)) } for (const i in this.attributes) { const [s, n] = this.attributes[i].split(":", 2); O(t, s, n) } t.ariaHidden = this.$el.ariaHidden, this.$el.id || si(t, "id") } const gd = Et(async t => { if (t) { const e = await fetch(t); if (e.headers.get("Content-Type") === "image/svg+xml") return e.text() } return Promise.reject() }); function md(t) { const e = Nr(t); e && u(t, "--uk-animation-stroke", e) } const Nn = ".uk-disabled *, .uk-disabled, [disabled]"; var ka = { mixins: [ge], args: "connect", props: { connect: String, toggle: String, itemNav: String, active: Number, followFocus: Boolean, swiping: Boolean }, data: { connect: "~.uk-switcher", toggle: "> * > :first-child", itemNav: !1, active: 0, cls: "uk-active", attrItem: "uk-switcher-item", selVertical: ".uk-nav", followFocus: !1, swiping: !0 }, computed: { connects: { get: ({ connect: t }, e) => li(t, e), observe: ({ connect: t }) => t }, connectChildren() { return this.connects.map(t => X(t)).flat() }, toggles: ({ toggle: t }, e) => G(t, e), children(t, e) { return X(e).filter(i => this.toggles.some(s => i.contains(s))) } }, watch: { connects(t) { this.swiping && u(t, "touchAction", "pan-y pinch-zoom"), this.$emit() }, connectChildren() { let t = Math.max(0, this.index()); for (const e of this.connects) X(e).forEach((i, s) => Z(i, this.cls, s === t)); this.$emit() }, toggles(t) { this.$emit(); const e = this.index(); this.show(~e ? e : t[this.active] || t[0]) } }, connected() { this.$el.role = "tablist" }, observe: [ns({ targets: ({ connectChildren: t }) => t }), Ko({ target: ({ connects: t }) => t, filter: ({ swiping: t }) => t })], events: [{ name: "click keydown", delegate: ({ toggle: t }) => t, handler(t) { !R(t.current, Nn) && (t.type === "click" || t.keyCode === Y.SPACE) && (qt(t), this.show(t.current)) } }, { name: "keydown", delegate: ({ toggle: t }) => t, handler(t) { const { current: e, keyCode: i } = t, s = R(this.$el, this.selVertical); let n = i === Y.HOME ? 0 : i === Y.END ? "last" : i === Y.LEFT && !s || i === Y.UP && s ? "previous" : i === Y.RIGHT && !s || i === Y.DOWN && s ? "next" : -1; if (~n) { t.preventDefault(); const o = this.toggles.filter(a => !R(a, Nn)), r = o[kt(n, o, o.indexOf(e))]; r.focus(), this.followFocus && this.show(r) } } }, { name: "click", el: ({ $el: t, connects: e, itemNav: i }) => e.concat(i ? li(i, t) : []), delegate: ({ attrItem: t }) => `[${t}],[data-${t}]`, handler(t) { t.target.closest("a,button") && (qt(t), this.show(mt(t.current, this.attrItem))) } }, { name: "swipeRight swipeLeft", filter: ({ swiping: t }) => t, el: ({ connects: t }) => t, handler({ type: t }) { this.show(E(t, "Left") ? "next" : "previous") } }], update() { var t; for (const e of this.connects) Q(e, "ul") && (e.role = "presentation"); O(X(this.$el), "role", "presentation"); for (const e in this.toggles) { const i = this.toggles[e], s = (t = this.connects[0]) == null ? void 0 : t.children[e]; i.role = "tab", s && (i.id = $e(this, i), s.id = $e(this, s), i.ariaControls = s.id, O(s, { role: "tabpanel", "aria-labelledby": i.id })) } O(this.$el, "aria-orientation", R(this.$el, this.selVertical) ? "vertical" : null) }, methods: { index() { return H(this.children, t => T(t, this.cls)) }, show(t) { const e = this.toggles.filter(r => !R(r, Nn)), i = this.index(), s = kt(!ti(t) || x(e, t) ? t : 0, e, kt(this.toggles[i], e)), n = kt(e[s], this.toggles); this.children.forEach((r, a) => { Z(r, this.cls, n === a), O(this.toggles[a], { "aria-selected": n === a, tabindex: n === a ? null : -1 }) }); const o = i >= 0 && i !== s; this.connects.forEach(async ({ children: r }) => { const a = pt(r).filter((c, g) => g !== n && T(c, this.cls)); await this.toggleElement(a, !1, o) && await this.toggleElement(r[n], !0, o) }) } } }, vd = { mixins: [wt], extends: ka, props: { media: Boolean }, data: { media: 960, attrItem: "uk-tab-item", selVertical: ".uk-tab-left,.uk-tab-right" }, connected() { const t = T(this.$el, "uk-tab-left") ? "uk-tab-left" : T(this.$el, "uk-tab-right") ? "uk-tab-right" : !1; t && this.$create("toggle", this.$el, { cls: t, mode: "media", media: this.media }) } }; const $d = 13, bd = 32; var wd = { mixins: [cs, ge], args: "target", props: { href: String, target: null, mode: "list", queued: Boolean }, data: { href: !1, target: !1, mode: "click", queued: !0 }, computed: { target: { get: ({ target: t }, e) => (t = li(t || e.hash, e), t.length ? t : [e]), observe: ({ target: t }) => t } }, connected() { x(this.mode, "media") || (ri(this.$el) || (this.$el.tabIndex = 0), !this.cls && Q(this.$el, "a") && (this.$el.role = "button")) }, observe: ns({ targets: ({ target: t }) => t }), events: [{ name: Ct, filter: ({ mode: t }) => x(t, "hover"), handler(t) { this._preventClick = null, !(!It(t) || Ae(this._showState) || this.$el.disabled) && (_(this.$el, "focus"), K(document, Ct, () => _(this.$el, "blur"), !0, e => !this.$el.contains(e.target)), x(this.mode, "click") && (this._preventClick = !0)) } }, { name: `${Vt} ${Gt} focus blur`, filter: ({ mode: t }) => x(t, "hover"), handler(t) { if (It(t) || this.$el.disabled || document.readyState === "loading") return; const e = x([Vt, "focus"], t.type), i = this.isToggled(this.target); if (!e && (!Ae(this._showState) || t.type === Gt && R(this.$el, ":focus") || t.type === "blur" && R(this.$el, ":hover"))) { i === this._showState && (this._showState = null); return } e && Ae(this._showState) && i !== this._showState || (this._showState = e ? i : null, this.toggle(`toggle${e ? "show" : "hide"}`)) } }, { name: "keydown", filter: ({ $el: t, mode: e }) => x(e, "click") && !Q(t, "input"), handler(t) { (t.keyCode === bd || t.keyCode === $d) && (t.preventDefault(), this.$el.click()) } }, { name: "click", filter: ({ mode: t }) => ["click", "hover"].some(e => x(t, e)), handler(t) { if (t.defaultPrevented) return; const e = t.target.closest("a[href]"), i = Me(e) && (!e.hash || R(this.target, e.hash)); (this._preventClick || i || e && !this.isToggled(this.target)) && t.preventDefault(), !this._preventClick && x(this.mode, "click") && (!e || i || t.defaultPrevented) && this.toggle() } }, { name: "mediachange", filter: ({ mode: t }) => x(t, "media"), el: ({ target: t }) => t, handler(t, e) { e.matches ^ this.isToggled(this.target) && this.toggle() } }], methods: { async toggle(t) { if (!_(this.target, t || "toggle", [this])) return; if (Lt(this.$el, "aria-expanded") && (this.$el.ariaExpanded = !this.isToggled(this.target)), !this.queued) return this.toggleElement(this.target); const e = this.target.filter(s => T(s, this.clsLeave)); if (e.length) { for (const s of this.target) { const n = x(e, s); this.toggleElement(s, n, n) } return } const i = this.target.filter(this.isToggled); await this.toggleElement(i, !1) && await this.toggleElement(this.target.filter(s => !x(i, s)), !0) } } }, xd = Object.freeze({ __proto__: null, Accordion: ra, Alert: Wh, Close: Lu, Cover: Yh, Drop: ca, DropParentIcon: we, Dropdown: ca, Dropnav: ua, FormCustom: iu, Grid: su, HeightMatch: au, HeightPlaceholder: hu, HeightViewport: uu, Icon: Cn, Img: fc, Inverse: Yu, Leader: Ku, Margin: Zo, Marker: Fu, Modal: Zu, Nav: td, NavParentIcon: Nu, Navbar: ed, NavbarParentIcon: we, NavbarToggleIcon: zu, Offcanvas: id, OverflowAuto: od, OverflowFade: rd, OverlayIcon: we, PaginationNext: Ru, PaginationPrevious: qu, Responsive: ad, Scroll: ld, Scrollspy: ud, ScrollspyNav: dd, SearchIcon: Bu, SlidenavNext: $a, SlidenavPrevious: $a, Spinner: Hu, Sticky: fd, Svg: pd, Switcher: ka, Tab: vd, Toggle: wd, Totop: ju, Video: aa }); return Ee(xd, (t, e) => At.component(e, t)), Fh(At), Ee(Lh, (t, e) => At.component(e, t)), At })) })(Bi)), Bi.exports } var ul = hl(); const dl = ll(ul); window.Lit = Ua, window.LitDecorators = el, window.LitRepeat = { repeat: rl }, window.LitUnsafeHTML = { unsafeHTML: al }, window.UIkit = dl
})();
